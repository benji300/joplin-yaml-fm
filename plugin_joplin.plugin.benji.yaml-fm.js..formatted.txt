!function(e) {
    var t = {};
    function n(r) {
        if (t[r])
            return t[r].exports;
        var s = t[r] = {
            i: r,
            l: !1,
            exports: {}
        };
        return e[r].call(s.exports, s, s.exports, n),
        s.l = !0,
        s.exports
    }
    n.m = e,
    n.c = t,
    n.d = function(e, t, r) {
        n.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: r
        })
    }
    ,
    n.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    n.t = function(e, t) {
        if (1 & t && (e = n(e)),
        8 & t)
            return e;
        if (4 & t && "object" == typeof e && e && e.__esModule)
            return e;
        var r = Object.create(null);
        if (n.r(r),
        Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
        }),
        2 & t && "string" != typeof e)
            for (var s in e)
                n.d(r, s, function(t) {
                    return e[t]
                }
                .bind(null, s));
        return r
    }
    ,
    n.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return n.d(t, "a", t),
        t
    }
    ,
    n.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    n.p = "",
    n(n.s = 5)
}([function(e, t, n) {
    "use strict";
    const r = {
        ANCHOR: "&",
        COMMENT: "#",
        TAG: "!",
        DIRECTIVES_END: "-",
        DOCUMENT_END: "."
    }
      , s = {
        ALIAS: "ALIAS",
        BLANK_LINE: "BLANK_LINE",
        BLOCK_FOLDED: "BLOCK_FOLDED",
        BLOCK_LITERAL: "BLOCK_LITERAL",
        COMMENT: "COMMENT",
        DIRECTIVE: "DIRECTIVE",
        DOCUMENT: "DOCUMENT",
        FLOW_MAP: "FLOW_MAP",
        FLOW_SEQ: "FLOW_SEQ",
        MAP: "MAP",
        MAP_KEY: "MAP_KEY",
        MAP_VALUE: "MAP_VALUE",
        PLAIN: "PLAIN",
        QUOTE_DOUBLE: "QUOTE_DOUBLE",
        QUOTE_SINGLE: "QUOTE_SINGLE",
        SEQ: "SEQ",
        SEQ_ITEM: "SEQ_ITEM"
    };
    function i(e) {
        const t = [0];
        let n = e.indexOf("\n");
        for (; -1 !== n; )
            n += 1,
            t.push(n),
            n = e.indexOf("\n", n);
        return t
    }
    function o(e) {
        let t, n;
        return "string" == typeof e ? (t = i(e),
        n = e) : (Array.isArray(e) && (e = e[0]),
        e && e.context && (e.lineStarts || (e.lineStarts = i(e.context.src)),
        t = e.lineStarts,
        n = e.context.src)),
        {
            lineStarts: t,
            src: n
        }
    }
    function a(e, t) {
        if ("number" != typeof e || e < 0)
            return null;
        const {lineStarts: n, src: r} = o(t);
        if (!n || !r || e > r.length)
            return null;
        for (let t = 0; t < n.length; ++t) {
            const r = n[t];
            if (e < r)
                return {
                    line: t,
                    col: e - n[t - 1] + 1
                };
            if (e === r)
                return {
                    line: t + 1,
                    col: 1
                }
        }
        const s = n.length;
        return {
            line: s,
            col: e - n[s - 1] + 1
        }
    }
    function c({start: e, end: t}, n, r=80) {
        let s = function(e, t) {
            const {lineStarts: n, src: r} = o(t);
            if (!n || !(e >= 1) || e > n.length)
                return null;
            const s = n[e - 1];
            let i = n[e];
            for (; i && i > s && "\n" === r[i - 1]; )
                --i;
            return r.slice(s, i)
        }(e.line, n);
        if (!s)
            return null;
        let {col: i} = e;
        if (s.length > r)
            if (i <= r - 10)
                s = s.substr(0, r - 1) + "…";
            else {
                const e = Math.round(r / 2);
                s.length > i + e && (s = s.substr(0, i + e - 1) + "…"),
                i -= s.length - r,
                s = "…" + s.substr(1 - r)
            }
        let a = 1
          , c = "";
        t && (t.line === e.line && i + (t.col - e.col) <= r + 1 ? a = t.col - e.col : (a = Math.min(s.length + 1, r) - i,
        c = "…"));
        return `${s}\n${i > 1 ? " ".repeat(i - 1) : ""}${"^".repeat(a)}${c}`
    }
    class l {
        static copy(e) {
            return new l(e.start,e.end)
        }
        constructor(e, t) {
            this.start = e,
            this.end = t || e
        }
        isEmpty() {
            return "number" != typeof this.start || !this.end || this.end <= this.start
        }
        setOrigRange(e, t) {
            const {start: n, end: r} = this;
            if (0 === e.length || r <= e[0])
                return this.origStart = n,
                this.origEnd = r,
                t;
            let s = t;
            for (; s < e.length && !(e[s] > n); )
                ++s;
            this.origStart = n + s;
            const i = s;
            for (; s < e.length && !(e[s] >= r); )
                ++s;
            return this.origEnd = r + s,
            i
        }
    }
    class u {
        static addStringTerminator(e, t, n) {
            if ("\n" === n[n.length - 1])
                return n;
            const r = u.endOfWhiteSpace(e, t);
            return r >= e.length || "\n" === e[r] ? n + "\n" : n
        }
        static atDocumentBoundary(e, t, n) {
            const s = e[t];
            if (!s)
                return !0;
            const i = e[t - 1];
            if (i && "\n" !== i)
                return !1;
            if (n) {
                if (s !== n)
                    return !1
            } else if (s !== r.DIRECTIVES_END && s !== r.DOCUMENT_END)
                return !1;
            const o = e[t + 1]
              , a = e[t + 2];
            if (o !== s || a !== s)
                return !1;
            const c = e[t + 3];
            return !c || "\n" === c || "\t" === c || " " === c
        }
        static endOfIdentifier(e, t) {
            let n = e[t];
            const r = "<" === n
              , s = r ? ["\n", "\t", " ", ">"] : ["\n", "\t", " ", "[", "]", "{", "}", ","];
            for (; n && -1 === s.indexOf(n); )
                n = e[t += 1];
            return r && ">" === n && (t += 1),
            t
        }
        static endOfIndent(e, t) {
            let n = e[t];
            for (; " " === n; )
                n = e[t += 1];
            return t
        }
        static endOfLine(e, t) {
            let n = e[t];
            for (; n && "\n" !== n; )
                n = e[t += 1];
            return t
        }
        static endOfWhiteSpace(e, t) {
            let n = e[t];
            for (; "\t" === n || " " === n; )
                n = e[t += 1];
            return t
        }
        static startOfLine(e, t) {
            let n = e[t - 1];
            if ("\n" === n)
                return t;
            for (; n && "\n" !== n; )
                n = e[t -= 1];
            return t + 1
        }
        static endOfBlockIndent(e, t, n) {
            const r = u.endOfIndent(e, n);
            if (r > n + t)
                return r;
            {
                const t = u.endOfWhiteSpace(e, r)
                  , n = e[t];
                if (!n || "\n" === n)
                    return t
            }
            return null
        }
        static atBlank(e, t, n) {
            const r = e[t];
            return "\n" === r || "\t" === r || " " === r || n && !r
        }
        static nextNodeIsIndented(e, t, n) {
            return !(!e || t < 0) && (t > 0 || n && "-" === e)
        }
        static normalizeOffset(e, t) {
            const n = e[t];
            return n ? "\n" !== n && "\n" === e[t - 1] ? t - 1 : u.endOfWhiteSpace(e, t) : t
        }
        static foldNewline(e, t, n) {
            let r = 0
              , s = !1
              , i = ""
              , o = e[t + 1];
            for (; " " === o || "\t" === o || "\n" === o; ) {
                switch (o) {
                case "\n":
                    r = 0,
                    t += 1,
                    i += "\n";
                    break;
                case "\t":
                    r <= n && (s = !0),
                    t = u.endOfWhiteSpace(e, t + 2) - 1;
                    break;
                case " ":
                    r += 1,
                    t += 1
                }
                o = e[t + 1]
            }
            return i || (i = " "),
            o && r <= n && (s = !0),
            {
                fold: i,
                offset: t,
                error: s
            }
        }
        constructor(e, t, n) {
            Object.defineProperty(this, "context", {
                value: n || null,
                writable: !0
            }),
            this.error = null,
            this.range = null,
            this.valueRange = null,
            this.props = t || [],
            this.type = e,
            this.value = null
        }
        getPropValue(e, t, n) {
            if (!this.context)
                return null;
            const {src: r} = this.context
              , s = this.props[e];
            return s && r[s.start] === t ? r.slice(s.start + (n ? 1 : 0), s.end) : null
        }
        get anchor() {
            for (let e = 0; e < this.props.length; ++e) {
                const t = this.getPropValue(e, r.ANCHOR, !0);
                if (null != t)
                    return t
            }
            return null
        }
        get comment() {
            const e = [];
            for (let t = 0; t < this.props.length; ++t) {
                const n = this.getPropValue(t, r.COMMENT, !0);
                null != n && e.push(n)
            }
            return e.length > 0 ? e.join("\n") : null
        }
        commentHasRequiredWhitespace(e) {
            const {src: t} = this.context;
            if (this.header && e === this.header.end)
                return !1;
            if (!this.valueRange)
                return !1;
            const {end: n} = this.valueRange;
            return e !== n || u.atBlank(t, n - 1)
        }
        get hasComment() {
            if (this.context) {
                const {src: e} = this.context;
                for (let t = 0; t < this.props.length; ++t)
                    if (e[this.props[t].start] === r.COMMENT)
                        return !0
            }
            return !1
        }
        get hasProps() {
            if (this.context) {
                const {src: e} = this.context;
                for (let t = 0; t < this.props.length; ++t)
                    if (e[this.props[t].start] !== r.COMMENT)
                        return !0
            }
            return !1
        }
        get includesTrailingLines() {
            return !1
        }
        get jsonLike() {
            return -1 !== [s.FLOW_MAP, s.FLOW_SEQ, s.QUOTE_DOUBLE, s.QUOTE_SINGLE].indexOf(this.type)
        }
        get rangeAsLinePos() {
            if (!this.range || !this.context)
                return;
            const e = a(this.range.start, this.context.root);
            if (!e)
                return;
            return {
                start: e,
                end: a(this.range.end, this.context.root)
            }
        }
        get rawValue() {
            if (!this.valueRange || !this.context)
                return null;
            const {start: e, end: t} = this.valueRange;
            return this.context.src.slice(e, t)
        }
        get tag() {
            for (let e = 0; e < this.props.length; ++e) {
                const t = this.getPropValue(e, r.TAG, !1);
                if (null != t) {
                    if ("<" === t[1])
                        return {
                            verbatim: t.slice(2, -1)
                        };
                    {
                        const [e,n,r] = t.match(/^(.*!)([^!]*)$/);
                        return {
                            handle: n,
                            suffix: r
                        }
                    }
                }
            }
            return null
        }
        get valueRangeContainsNewline() {
            if (!this.valueRange || !this.context)
                return !1;
            const {start: e, end: t} = this.valueRange
              , {src: n} = this.context;
            for (let r = e; r < t; ++r)
                if ("\n" === n[r])
                    return !0;
            return !1
        }
        parseComment(e) {
            const {src: t} = this.context;
            if (t[e] === r.COMMENT) {
                const n = u.endOfLine(t, e + 1)
                  , r = new l(e,n);
                return this.props.push(r),
                n
            }
            return e
        }
        setOrigRanges(e, t) {
            return this.range && (t = this.range.setOrigRange(e, t)),
            this.valueRange && this.valueRange.setOrigRange(e, t),
            this.props.forEach(n=>n.setOrigRange(e, t)),
            t
        }
        toString() {
            const {context: {src: e}, range: t, value: n} = this;
            if (null != n)
                return n;
            const r = e.slice(t.start, t.end);
            return u.addStringTerminator(e, t.end, r)
        }
    }
    class f extends Error {
        constructor(e, t, n) {
            if (!(n && t instanceof u))
                throw new Error("Invalid arguments for new " + e);
            super(),
            this.name = e,
            this.message = n,
            this.source = t
        }
        makePretty() {
            if (!this.source)
                return;
            this.nodeType = this.source.type;
            const e = this.source.context && this.source.context.root;
            if ("number" == typeof this.offset) {
                this.range = new l(this.offset,this.offset + 1);
                const t = e && a(this.offset, e);
                if (t) {
                    const e = {
                        line: t.line,
                        col: t.col + 1
                    };
                    this.linePos = {
                        start: t,
                        end: e
                    }
                }
                delete this.offset
            } else
                this.range = this.source.range,
                this.linePos = this.source.rangeAsLinePos;
            if (this.linePos) {
                const {line: t, col: n} = this.linePos.start;
                this.message += ` at line ${t}, column ${n}`;
                const r = e && c(this.linePos, e);
                r && (this.message += `:\n\n${r}\n`)
            }
            delete this.source
        }
    }
    class h extends f {
        constructor(e, t) {
            super("YAMLSemanticError", e, t)
        }
    }
    class d extends u {
        static endOfLine(e, t, n) {
            let r = e[t]
              , s = t;
            for (; r && "\n" !== r && (!n || "[" !== r && "]" !== r && "{" !== r && "}" !== r && "," !== r); ) {
                const t = e[s + 1];
                if (":" === r && (!t || "\n" === t || "\t" === t || " " === t || n && "," === t))
                    break;
                if ((" " === r || "\t" === r) && "#" === t)
                    break;
                s += 1,
                r = t
            }
            return s
        }
        get strValue() {
            if (!this.valueRange || !this.context)
                return null;
            let {start: e, end: t} = this.valueRange;
            const {src: n} = this.context;
            let r = n[t - 1];
            for (; e < t && ("\n" === r || "\t" === r || " " === r); )
                r = n[--t - 1];
            let s = "";
            for (let r = e; r < t; ++r) {
                const e = n[r];
                if ("\n" === e) {
                    const {fold: e, offset: t} = u.foldNewline(n, r, -1);
                    s += e,
                    r = t
                } else if (" " === e || "\t" === e) {
                    const i = r;
                    let o = n[r + 1];
                    for (; r < t && (" " === o || "\t" === o); )
                        r += 1,
                        o = n[r + 1];
                    "\n" !== o && (s += r > i ? n.slice(i, r + 1) : e)
                } else
                    s += e
            }
            const i = n[e];
            switch (i) {
            case "\t":
                return {
                    errors: [new h(this,"Plain value cannot start with a tab character")],
                    str: s
                };
            case "@":
            case "`":
                return {
                    errors: [new h(this,"Plain value cannot start with reserved character " + i)],
                    str: s
                };
            default:
                return s
            }
        }
        parseBlockValue(e) {
            const {indent: t, inFlow: n, src: r} = this.context;
            let s = e
              , i = e;
            for (let e = r[s]; "\n" === e && !u.atDocumentBoundary(r, s + 1); e = r[s]) {
                const e = u.endOfBlockIndent(r, t, s + 1);
                if (null === e || "#" === r[e])
                    break;
                "\n" === r[e] ? s = e : (i = d.endOfLine(r, e, n),
                s = i)
            }
            return this.valueRange.isEmpty() && (this.valueRange.start = e),
            this.valueRange.end = i,
            i
        }
        parse(e, t) {
            this.context = e;
            const {inFlow: n, src: r} = e;
            let s = t;
            const i = r[s];
            return i && "#" !== i && "\n" !== i && (s = d.endOfLine(r, t, n)),
            this.valueRange = new l(t,s),
            s = u.endOfWhiteSpace(r, s),
            s = this.parseComment(s),
            this.hasComment && !this.valueRange.isEmpty() || (s = this.parseBlockValue(s)),
            s
        }
    }
    t.Char = r,
    t.Node = u,
    t.PlainValue = d,
    t.Range = l,
    t.Type = s,
    t.YAMLError = f,
    t.YAMLReferenceError = class extends f {
        constructor(e, t) {
            super("YAMLReferenceError", e, t)
        }
    }
    ,
    t.YAMLSemanticError = h,
    t.YAMLSyntaxError = class extends f {
        constructor(e, t) {
            super("YAMLSyntaxError", e, t)
        }
    }
    ,
    t.YAMLWarning = class extends f {
        constructor(e, t) {
            super("YAMLWarning", e, t)
        }
    }
    ,
    t._defineProperty = function(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n,
        e
    }
    ,
    t.defaultTagPrefix = "tag:yaml.org,2002:",
    t.defaultTags = {
        MAP: "tag:yaml.org,2002:map",
        SEQ: "tag:yaml.org,2002:seq",
        STR: "tag:yaml.org,2002:str"
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(0);
    function s(e, t, n) {
        return n ? -1 === n.indexOf("\n") ? `${e} #${n}` : e + "\n" + n.replace(/^/gm, (t || "") + "#") : e
    }
    class i {
    }
    function o(e, t, n) {
        if (Array.isArray(e))
            return e.map((e,t)=>o(e, String(t), n));
        if (e && "function" == typeof e.toJSON) {
            const r = n && n.anchors && n.anchors.get(e);
            r && (n.onCreate = e=>{
                r.res = e,
                delete n.onCreate
            }
            );
            const s = e.toJSON(t, n);
            return r && n.onCreate && n.onCreate(s),
            s
        }
        return n && n.keep || "bigint" != typeof e ? e : Number(e)
    }
    class a extends i {
        constructor(e) {
            super(),
            this.value = e
        }
        toJSON(e, t) {
            return t && t.keep ? this.value : o(this.value, e, t)
        }
        toString() {
            return String(this.value)
        }
    }
    function c(e, t, n) {
        let r = n;
        for (let e = t.length - 1; e >= 0; --e) {
            const n = t[e];
            if (Number.isInteger(n) && n >= 0) {
                const e = [];
                e[n] = r,
                r = e
            } else {
                const e = {};
                Object.defineProperty(e, n, {
                    value: r,
                    writable: !0,
                    enumerable: !0,
                    configurable: !0
                }),
                r = e
            }
        }
        return e.createNode(r, !1)
    }
    const l = e=>null == e || "object" == typeof e && e[Symbol.iterator]().next().done;
    class u extends i {
        constructor(e) {
            super(),
            r._defineProperty(this, "items", []),
            this.schema = e
        }
        addIn(e, t) {
            if (l(e))
                this.add(t);
            else {
                const [n,...r] = e
                  , s = this.get(n, !0);
                if (s instanceof u)
                    s.addIn(r, t);
                else {
                    if (void 0 !== s || !this.schema)
                        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`);
                    this.set(n, c(this.schema, r, t))
                }
            }
        }
        deleteIn([e,...t]) {
            if (0 === t.length)
                return this.delete(e);
            const n = this.get(e, !0);
            if (n instanceof u)
                return n.deleteIn(t);
            throw new Error(`Expected YAML collection at ${e}. Remaining path: ${t}`)
        }
        getIn([e,...t], n) {
            const r = this.get(e, !0);
            return 0 === t.length ? !n && r instanceof a ? r.value : r : r instanceof u ? r.getIn(t, n) : void 0
        }
        hasAllNullValues() {
            return this.items.every(e=>{
                if (!e || "PAIR" !== e.type)
                    return !1;
                const t = e.value;
                return null == t || t instanceof a && null == t.value && !t.commentBefore && !t.comment && !t.tag
            }
            )
        }
        hasIn([e,...t]) {
            if (0 === t.length)
                return this.has(e);
            const n = this.get(e, !0);
            return n instanceof u && n.hasIn(t)
        }
        setIn([e,...t], n) {
            if (0 === t.length)
                this.set(e, n);
            else {
                const r = this.get(e, !0);
                if (r instanceof u)
                    r.setIn(t, n);
                else {
                    if (void 0 !== r || !this.schema)
                        throw new Error(`Expected YAML collection at ${e}. Remaining path: ${t}`);
                    this.set(e, c(this.schema, t, n))
                }
            }
        }
        toJSON() {
            return null
        }
        toString(e, {blockItem: t, flowChars: n, isMap: i, itemIndent: o}, a, c) {
            const {indent: l, indentStep: f, stringify: h} = e
              , d = this.type === r.Type.FLOW_MAP || this.type === r.Type.FLOW_SEQ || e.inFlow;
            d && (o += f);
            const p = i && this.hasAllNullValues();
            e = Object.assign({}, e, {
                allNullValues: p,
                indent: o,
                inFlow: d,
                type: null
            });
            let g = !1
              , m = !1;
            const y = this.items.reduce((t,n,r)=>{
                let i;
                n && (!g && n.spaceBefore && t.push({
                    type: "comment",
                    str: ""
                }),
                n.commentBefore && n.commentBefore.match(/^.*$/gm).forEach(e=>{
                    t.push({
                        type: "comment",
                        str: "#" + e
                    })
                }
                ),
                n.comment && (i = n.comment),
                d && (!g && n.spaceBefore || n.commentBefore || n.comment || n.key && (n.key.commentBefore || n.key.comment) || n.value && (n.value.commentBefore || n.value.comment)) && (m = !0)),
                g = !1;
                let a = h(n, e, ()=>i = null, ()=>g = !0);
                return d && !m && a.includes("\n") && (m = !0),
                d && r < this.items.length - 1 && (a += ","),
                a = s(a, o, i),
                g && (i || d) && (g = !1),
                t.push({
                    type: "item",
                    str: a
                }),
                t
            }
            , []);
            let v;
            if (0 === y.length)
                v = n.start + n.end;
            else if (d) {
                const {start: e, end: t} = n
                  , r = y.map(e=>e.str);
                if (m || r.reduce((e,t)=>e + t.length + 2, 2) > u.maxFlowStringSingleLineLength) {
                    v = e;
                    for (const e of r)
                        v += e ? `\n${f}${l}${e}` : "\n";
                    v += `\n${l}${t}`
                } else
                    v = `${e} ${r.join(" ")} ${t}`
            } else {
                const e = y.map(t);
                v = e.shift();
                for (const t of e)
                    v += t ? `\n${l}${t}` : "\n"
            }
            return this.comment ? (v += "\n" + this.comment.replace(/^/gm, l + "#"),
            a && a()) : g && c && c(),
            v
        }
    }
    function f(e) {
        let t = e instanceof a ? e.value : e;
        return t && "string" == typeof t && (t = Number(t)),
        Number.isInteger(t) && t >= 0 ? t : null
    }
    r._defineProperty(u, "maxFlowStringSingleLineLength", 60);
    class h extends u {
        add(e) {
            this.items.push(e)
        }
        delete(e) {
            const t = f(e);
            if ("number" != typeof t)
                return !1;
            return this.items.splice(t, 1).length > 0
        }
        get(e, t) {
            const n = f(e);
            if ("number" != typeof n)
                return;
            const r = this.items[n];
            return !t && r instanceof a ? r.value : r
        }
        has(e) {
            const t = f(e);
            return "number" == typeof t && t < this.items.length
        }
        set(e, t) {
            const n = f(e);
            if ("number" != typeof n)
                throw new Error(`Expected a valid index, not ${e}.`);
            this.items[n] = t
        }
        toJSON(e, t) {
            const n = [];
            t && t.onCreate && t.onCreate(n);
            let r = 0;
            for (const e of this.items)
                n.push(o(e, String(r++), t));
            return n
        }
        toString(e, t, n) {
            return e ? super.toString(e, {
                blockItem: e=>"comment" === e.type ? e.str : "- " + e.str,
                flowChars: {
                    start: "[",
                    end: "]"
                },
                isMap: !1,
                itemIndent: (e.indent || "") + "  "
            }, t, n) : JSON.stringify(this)
        }
    }
    class d extends i {
        constructor(e, t=null) {
            super(),
            this.key = e,
            this.value = t,
            this.type = d.Type.PAIR
        }
        get commentBefore() {
            return this.key instanceof i ? this.key.commentBefore : void 0
        }
        set commentBefore(e) {
            if (null == this.key && (this.key = new a(null)),
            !(this.key instanceof i)) {
                throw new Error("Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.")
            }
            this.key.commentBefore = e
        }
        addToJSMap(e, t) {
            const n = o(this.key, "", e);
            if (t instanceof Map) {
                const r = o(this.value, n, e);
                t.set(n, r)
            } else if (t instanceof Set)
                t.add(n);
            else {
                const r = ((e,t,n)=>null === t ? "" : "object" != typeof t ? String(t) : e instanceof i && n && n.doc ? e.toString({
                    anchors: Object.create(null),
                    doc: n.doc,
                    indent: "",
                    indentStep: n.indentStep,
                    inFlow: !0,
                    inStringifyKey: !0,
                    stringify: n.stringify
                }) : JSON.stringify(t))(this.key, n, e)
                  , s = o(this.value, r, e);
                r in t ? Object.defineProperty(t, r, {
                    value: s,
                    writable: !0,
                    enumerable: !0,
                    configurable: !0
                }) : t[r] = s
            }
            return t
        }
        toJSON(e, t) {
            const n = t && t.mapAsMap ? new Map : {};
            return this.addToJSMap(t, n)
        }
        toString(e, t, n) {
            if (!e || !e.doc)
                return JSON.stringify(this);
            const {indent: o, indentSeq: c, simpleKeys: l} = e.doc.options;
            let {key: f, value: d} = this
              , p = f instanceof i && f.comment;
            if (l) {
                if (p)
                    throw new Error("With simple keys, key nodes cannot have comments");
                if (f instanceof u) {
                    throw new Error("With simple keys, collection cannot be used as a key value")
                }
            }
            let g = !l && (!f || p || (f instanceof i ? f instanceof u || f.type === r.Type.BLOCK_FOLDED || f.type === r.Type.BLOCK_LITERAL : "object" == typeof f));
            const {doc: m, indent: y, indentStep: v, stringify: S} = e;
            e = Object.assign({}, e, {
                implicitKey: !g,
                indent: y + v
            });
            let b = !1
              , w = S(f, e, ()=>p = null, ()=>b = !0);
            if (w = s(w, e.indent, p),
            !g && w.length > 1024) {
                if (l)
                    throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
                g = !0
            }
            if (e.allNullValues && !l)
                return this.comment ? (w = s(w, e.indent, this.comment),
                t && t()) : b && !p && n && n(),
                e.inFlow && !g ? w : "? " + w;
            w = g ? `? ${w}\n${y}:` : w + ":",
            this.comment && (w = s(w, e.indent, this.comment),
            t && t());
            let E = ""
              , O = null;
            if (d instanceof i) {
                if (d.spaceBefore && (E = "\n"),
                d.commentBefore) {
                    E += "\n" + d.commentBefore.replace(/^/gm, e.indent + "#")
                }
                O = d.comment
            } else
                d && "object" == typeof d && (d = m.schema.createNode(d, !0));
            e.implicitKey = !1,
            !g && !this.comment && d instanceof a && (e.indentAtStart = w.length + 1),
            b = !1,
            !c && o >= 2 && !e.inFlow && !g && d instanceof h && d.type !== r.Type.FLOW_SEQ && !d.tag && !m.anchors.getName(d) && (e.indent = e.indent.substr(2));
            const N = S(d, e, ()=>O = null, ()=>b = !0);
            let M = " ";
            if (E || this.comment)
                M = `${E}\n${e.indent}`;
            else if (!g && d instanceof u) {
                ("[" === N[0] || "{" === N[0]) && !N.includes("\n") || (M = "\n" + e.indent)
            } else
                "\n" === N[0] && (M = "");
            return b && !O && n && n(),
            s(w + M + N, e.indent, O)
        }
    }
    r._defineProperty(d, "Type", {
        PAIR: "PAIR",
        MERGE_PAIR: "MERGE_PAIR"
    });
    const p = (e,t)=>{
        if (e instanceof g) {
            const n = t.get(e.source);
            return n.count * n.aliasCount
        }
        if (e instanceof u) {
            let n = 0;
            for (const r of e.items) {
                const e = p(r, t);
                e > n && (n = e)
            }
            return n
        }
        if (e instanceof d) {
            const n = p(e.key, t)
              , r = p(e.value, t);
            return Math.max(n, r)
        }
        return 1
    }
    ;
    class g extends i {
        static stringify({range: e, source: t}, {anchors: n, doc: r, implicitKey: s, inStringifyKey: i}) {
            let o = Object.keys(n).find(e=>n[e] === t);
            if (!o && i && (o = r.anchors.getName(t) || r.anchors.newName()),
            o)
                return `*${o}${s ? " " : ""}`;
            const a = r.anchors.getName(t) ? "Alias node must be after source node" : "Source node not found for alias node";
            throw new Error(`${a} [${e}]`)
        }
        constructor(e) {
            super(),
            this.source = e,
            this.type = r.Type.ALIAS
        }
        set tag(e) {
            throw new Error("Alias nodes cannot have tags")
        }
        toJSON(e, t) {
            if (!t)
                return o(this.source, e, t);
            const {anchors: n, maxAliasCount: s} = t
              , i = n.get(this.source);
            if (!i || void 0 === i.res) {
                const e = "This should not happen: Alias anchor was not resolved?";
                throw this.cstNode ? new r.YAMLReferenceError(this.cstNode,e) : new ReferenceError(e)
            }
            if (s >= 0 && (i.count += 1,
            0 === i.aliasCount && (i.aliasCount = p(this.source, n)),
            i.count * i.aliasCount > s)) {
                const e = "Excessive alias count indicates a resource exhaustion attack";
                throw this.cstNode ? new r.YAMLReferenceError(this.cstNode,e) : new ReferenceError(e)
            }
            return i.res
        }
        toString(e) {
            return g.stringify(this, e)
        }
    }
    function m(e, t) {
        const n = t instanceof a ? t.value : t;
        for (const r of e)
            if (r instanceof d) {
                if (r.key === t || r.key === n)
                    return r;
                if (r.key && r.key.value === n)
                    return r
            }
    }
    r._defineProperty(g, "default", !0);
    class y extends u {
        add(e, t) {
            e ? e instanceof d || (e = new d(e.key || e,e.value)) : e = new d(e);
            const n = m(this.items, e.key)
              , r = this.schema && this.schema.sortMapEntries;
            if (n) {
                if (!t)
                    throw new Error(`Key ${e.key} already set`);
                n.value = e.value
            } else if (r) {
                const t = this.items.findIndex(t=>r(e, t) < 0);
                -1 === t ? this.items.push(e) : this.items.splice(t, 0, e)
            } else
                this.items.push(e)
        }
        delete(e) {
            const t = m(this.items, e);
            if (!t)
                return !1;
            return this.items.splice(this.items.indexOf(t), 1).length > 0
        }
        get(e, t) {
            const n = m(this.items, e)
              , r = n && n.value;
            return !t && r instanceof a ? r.value : r
        }
        has(e) {
            return !!m(this.items, e)
        }
        set(e, t) {
            this.add(new d(e,t), !0)
        }
        toJSON(e, t, n) {
            const r = n ? new n : t && t.mapAsMap ? new Map : {};
            t && t.onCreate && t.onCreate(r);
            for (const e of this.items)
                e.addToJSMap(t, r);
            return r
        }
        toString(e, t, n) {
            if (!e)
                return JSON.stringify(this);
            for (const e of this.items)
                if (!(e instanceof d))
                    throw new Error(`Map items must all be pairs; found ${JSON.stringify(e)} instead`);
            return super.toString(e, {
                blockItem: e=>e.str,
                flowChars: {
                    start: "{",
                    end: "}"
                },
                isMap: !0,
                itemIndent: e.indent || ""
            }, t, n)
        }
    }
    class v extends d {
        constructor(e) {
            if (e instanceof d) {
                let t = e.value;
                t instanceof h || (t = new h,
                t.items.push(e.value),
                t.range = e.value.range),
                super(e.key, t),
                this.range = e.range
            } else
                super(new a("<<"), new h);
            this.type = d.Type.MERGE_PAIR
        }
        addToJSMap(e, t) {
            for (const {source: n} of this.value.items) {
                if (!(n instanceof y))
                    throw new Error("Merge sources must be maps");
                const r = n.toJSON(null, e, Map);
                for (const [e,n] of r)
                    t instanceof Map ? t.has(e) || t.set(e, n) : t instanceof Set ? t.add(e) : Object.prototype.hasOwnProperty.call(t, e) || Object.defineProperty(t, e, {
                        value: n,
                        writable: !0,
                        enumerable: !0,
                        configurable: !0
                    })
            }
            return t
        }
        toString(e, t) {
            const n = this.value;
            if (n.items.length > 1)
                return super.toString(e, t);
            this.value = n.items[0];
            const r = super.toString(e, t);
            return this.value = n,
            r
        }
    }
    const S = {
        defaultType: r.Type.BLOCK_LITERAL,
        lineWidth: 76
    }
      , b = {
        defaultType: r.Type.PLAIN,
        doubleQuoted: {
            jsonEncoding: !1,
            minMultiLineLength: 40
        },
        fold: {
            lineWidth: 80,
            minContentWidth: 20
        }
    };
    function w(e, t, n) {
        for (const {format: n, test: r, resolve: s} of t)
            if (r) {
                const t = e.match(r);
                if (t) {
                    let e = s.apply(null, t);
                    return e instanceof a || (e = new a(e)),
                    n && (e.format = n),
                    e
                }
            }
        return n && (e = n(e)),
        new a(e)
    }
    const E = (e,t)=>{
        let n = e[t + 1];
        for (; " " === n || "\t" === n; ) {
            do {
                n = e[t += 1]
            } while (n && "\n" !== n);n = e[t + 1]
        }
        return t
    }
    ;
    function O(e, t, n, {indentAtStart: r, lineWidth: s=80, minContentWidth: i=20, onFold: o, onOverflow: a}) {
        if (!s || s < 0)
            return e;
        const c = Math.max(1 + i, 1 + s - t.length);
        if (e.length <= c)
            return e;
        const l = []
          , u = {};
        let f = s - t.length;
        "number" == typeof r && (r > s - Math.max(2, i) ? l.push(0) : f = s - r);
        let h, d = void 0, p = void 0, g = !1, m = -1, y = -1, v = -1;
        for ("block" === n && (m = E(e, m),
        -1 !== m && (f = m + c)); h = e[m += 1]; ) {
            if ("quoted" === n && "\\" === h) {
                switch (y = m,
                e[m + 1]) {
                case "x":
                    m += 3;
                    break;
                case "u":
                    m += 5;
                    break;
                case "U":
                    m += 9;
                    break;
                default:
                    m += 1
                }
                v = m
            }
            if ("\n" === h)
                "block" === n && (m = E(e, m)),
                f = m + c,
                d = void 0;
            else {
                if (" " === h && p && " " !== p && "\n" !== p && "\t" !== p) {
                    const t = e[m + 1];
                    t && " " !== t && "\n" !== t && "\t" !== t && (d = m)
                }
                if (m >= f)
                    if (d)
                        l.push(d),
                        f = d + c,
                        d = void 0;
                    else if ("quoted" === n) {
                        for (; " " === p || "\t" === p; )
                            p = h,
                            h = e[m += 1],
                            g = !0;
                        const t = m > v + 1 ? m - 2 : y - 1;
                        if (u[t])
                            return e;
                        l.push(t),
                        u[t] = !0,
                        f = t + c,
                        d = void 0
                    } else
                        g = !0
            }
            p = h
        }
        if (g && a && a(),
        0 === l.length)
            return e;
        o && o();
        let S = e.slice(0, l[0]);
        for (let r = 0; r < l.length; ++r) {
            const s = l[r]
              , i = l[r + 1] || e.length;
            0 === s ? S = `\n${t}${e.slice(0, i)}` : ("quoted" === n && u[s] && (S += e[s] + "\\"),
            S += `\n${t}${e.slice(s + 1, i)}`)
        }
        return S
    }
    const N = ({indentAtStart: e})=>e ? Object.assign({
        indentAtStart: e
    }, b.fold) : b.fold
      , M = e=>/^(%|---|\.\.\.)/m.test(e);
    function L(e, t) {
        const {implicitKey: n} = t
          , {jsonEncoding: r, minMultiLineLength: s} = b.doubleQuoted
          , i = JSON.stringify(e);
        if (r)
            return i;
        const o = t.indent || (M(e) ? "  " : "");
        let a = ""
          , c = 0;
        for (let e = 0, t = i[e]; t; t = i[++e])
            if (" " === t && "\\" === i[e + 1] && "n" === i[e + 2] && (a += i.slice(c, e) + "\\ ",
            e += 1,
            c = e,
            t = "\\"),
            "\\" === t)
                switch (i[e + 1]) {
                case "u":
                    {
                        a += i.slice(c, e);
                        const t = i.substr(e + 2, 4);
                        switch (t) {
                        case "0000":
                            a += "\\0";
                            break;
                        case "0007":
                            a += "\\a";
                            break;
                        case "000b":
                            a += "\\v";
                            break;
                        case "001b":
                            a += "\\e";
                            break;
                        case "0085":
                            a += "\\N";
                            break;
                        case "00a0":
                            a += "\\_";
                            break;
                        case "2028":
                            a += "\\L";
                            break;
                        case "2029":
                            a += "\\P";
                            break;
                        default:
                            "00" === t.substr(0, 2) ? a += "\\x" + t.substr(2) : a += i.substr(e, 6)
                        }
                        e += 5,
                        c = e + 1
                    }
                    break;
                case "n":
                    if (n || '"' === i[e + 2] || i.length < s)
                        e += 1;
                    else {
                        for (a += i.slice(c, e) + "\n\n"; "\\" === i[e + 2] && "n" === i[e + 3] && '"' !== i[e + 4]; )
                            a += "\n",
                            e += 2;
                        a += o,
                        " " === i[e + 2] && (a += "\\"),
                        e += 1,
                        c = e + 1
                    }
                    break;
                default:
                    e += 1
                }
        return a = c ? a + i.slice(c) : i,
        n ? a : O(a, o, "quoted", N(t))
    }
    function A(e, t) {
        if (t.implicitKey) {
            if (/\n/.test(e))
                return L(e, t)
        } else if (/[ \t]\n|\n[ \t]/.test(e))
            return L(e, t);
        const n = t.indent || (M(e) ? "  " : "")
          , r = "'" + e.replace(/'/g, "''").replace(/\n+/g, "$&\n" + n) + "'";
        return t.implicitKey ? r : O(r, n, "flow", N(t))
    }
    function T({comment: e, type: t, value: n}, s, i, o) {
        if (/\n[\t ]+$/.test(n) || /^\s*$/.test(n))
            return L(n, s);
        const a = s.indent || (s.forceBlockIndent || M(n) ? "  " : "")
          , c = a ? "2" : "1"
          , l = t !== r.Type.BLOCK_FOLDED && (t === r.Type.BLOCK_LITERAL || !function(e, t, n) {
            if (!t || t < 0)
                return !1;
            const r = t - n
              , s = e.length;
            if (s <= r)
                return !1;
            for (let t = 0, n = 0; t < s; ++t)
                if ("\n" === e[t]) {
                    if (t - n > r)
                        return !0;
                    if (n = t + 1,
                    s - n <= r)
                        return !1
                }
            return !0
        }(n, b.fold.lineWidth, a.length));
        let u = l ? "|" : ">";
        if (!n)
            return u + "\n";
        let f = ""
          , h = "";
        if (n = n.replace(/[\n\t ]*$/, e=>{
            const t = e.indexOf("\n");
            return -1 === t ? u += "-" : n !== e && t === e.length - 1 || (u += "+",
            o && o()),
            h = e.replace(/\n$/, ""),
            ""
        }
        ).replace(/^[\n ]*/, e=>{
            -1 !== e.indexOf(" ") && (u += c);
            const t = e.match(/ +$/);
            return t ? (f = e.slice(0, -t[0].length),
            t[0]) : (f = e,
            "")
        }
        ),
        h && (h = h.replace(/\n+(?!\n|$)/g, "$&" + a)),
        f && (f = f.replace(/\n+/g, "$&" + a)),
        e && (u += " #" + e.replace(/ ?[\r\n]+/g, " "),
        i && i()),
        !n)
            return `${u}${c}\n${a}${h}`;
        if (l)
            return n = n.replace(/\n+/g, "$&" + a),
            `${u}\n${a}${f}${n}${h}`;
        n = n.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&" + a);
        const d = O(`${f}${n}${h}`, a, "block", b.fold);
        return `${u}\n${a}${d}`
    }
    function x(e, t) {
        let n, s, i;
        switch (t.type) {
        case r.Type.FLOW_MAP:
            n = "}",
            s = "flow map";
            break;
        case r.Type.FLOW_SEQ:
            n = "]",
            s = "flow sequence";
            break;
        default:
            return void e.push(new r.YAMLSemanticError(t,"Not a flow collection!?"))
        }
        for (let e = t.items.length - 1; e >= 0; --e) {
            const n = t.items[e];
            if (!n || n.type !== r.Type.COMMENT) {
                i = n;
                break
            }
        }
        if (i && i.char !== n) {
            const o = `Expected ${s} to end with ${n}`;
            let a;
            "number" == typeof i.offset ? (a = new r.YAMLSemanticError(t,o),
            a.offset = i.offset + 1) : (a = new r.YAMLSemanticError(i,o),
            i.range && i.range.end && (a.offset = i.range.end - i.range.start)),
            e.push(a)
        }
    }
    function k(e, t) {
        const n = t.context.src[t.range.start - 1];
        if ("\n" !== n && "\t" !== n && " " !== n) {
            const n = "Comments must be separated from other tokens by white space characters";
            e.push(new r.YAMLSemanticError(t,n))
        }
    }
    function I(e, t) {
        const n = String(t)
          , s = n.substr(0, 8) + "..." + n.substr(-8);
        return new r.YAMLSemanticError(e,`The "${s}" key is too long`)
    }
    function _(e, t) {
        for (const {afterKey: n, before: r, comment: s} of t) {
            let t = e.items[r];
            t ? (n && t.value && (t = t.value),
            void 0 === s ? !n && t.commentBefore || (t.spaceBefore = !0) : t.commentBefore ? t.commentBefore += "\n" + s : t.commentBefore = s) : void 0 !== s && (e.comment ? e.comment += "\n" + s : e.comment = s)
        }
    }
    function C(e, t) {
        const n = t.strValue;
        return n ? "string" == typeof n ? n : (n.errors.forEach(n=>{
            n.source || (n.source = t),
            e.errors.push(n)
        }
        ),
        n.str) : ""
    }
    function P(e, t) {
        const {tag: n, type: s} = t;
        let i = !1;
        if (n) {
            const {handle: s, suffix: o, verbatim: a} = n;
            if (a) {
                if ("!" !== a && "!!" !== a)
                    return a;
                const n = `Verbatim tags aren't resolved, so ${a} is invalid.`;
                e.errors.push(new r.YAMLSemanticError(t,n))
            } else if ("!" !== s || o)
                try {
                    return function(e, t) {
                        const {handle: n, suffix: s} = t.tag;
                        let i = e.tagPrefixes.find(e=>e.handle === n);
                        if (!i) {
                            const s = e.getDefaults().tagPrefixes;
                            if (s && (i = s.find(e=>e.handle === n)),
                            !i)
                                throw new r.YAMLSemanticError(t,`The ${n} tag handle is non-default and was not declared.`)
                        }
                        if (!s)
                            throw new r.YAMLSemanticError(t,`The ${n} tag has no suffix.`);
                        if ("!" === n && "1.0" === (e.version || e.options.version)) {
                            if ("^" === s[0])
                                return e.warnings.push(new r.YAMLWarning(t,"YAML 1.0 ^ tag expansion is not supported")),
                                s;
                            if (/[:/]/.test(s)) {
                                const e = s.match(/^([a-z0-9-]+)\/(.*)/i);
                                return e ? `tag:${e[1]}.yaml.org,2002:${e[2]}` : "tag:" + s
                            }
                        }
                        return i.prefix + decodeURIComponent(s)
                    }(e, t)
                } catch (t) {
                    e.errors.push(t)
                }
            else
                i = !0
        }
        switch (s) {
        case r.Type.BLOCK_FOLDED:
        case r.Type.BLOCK_LITERAL:
        case r.Type.QUOTE_DOUBLE:
        case r.Type.QUOTE_SINGLE:
            return r.defaultTags.STR;
        case r.Type.FLOW_MAP:
        case r.Type.MAP:
            return r.defaultTags.MAP;
        case r.Type.FLOW_SEQ:
        case r.Type.SEQ:
            return r.defaultTags.SEQ;
        case r.Type.PLAIN:
            return i ? r.defaultTags.STR : null;
        default:
            return null
        }
    }
    function R(e, t, n) {
        const {tags: r} = e.schema
          , s = [];
        for (const i of r)
            if (i.tag === n) {
                if (!i.test) {
                    const n = i.resolve(e, t);
                    return n instanceof u ? n : new a(n)
                }
                s.push(i)
            }
        const i = C(e, t);
        return "string" == typeof i && s.length > 0 ? w(i, s, r.scalarFallback) : null
    }
    function $(e, t, n) {
        try {
            const r = R(e, t, n);
            if (r)
                return n && t.tag && (r.tag = n),
                r
        } catch (n) {
            return n.source || (n.source = t),
            e.errors.push(n),
            null
        }
        try {
            const s = function({type: e}) {
                switch (e) {
                case r.Type.FLOW_MAP:
                case r.Type.MAP:
                    return r.defaultTags.MAP;
                case r.Type.FLOW_SEQ:
                case r.Type.SEQ:
                    return r.defaultTags.SEQ;
                default:
                    return r.defaultTags.STR
                }
            }(t);
            if (!s)
                throw new Error(`The tag ${n} is unavailable`);
            const i = `The tag ${n} is unavailable, falling back to ${s}`;
            e.warnings.push(new r.YAMLWarning(t,i));
            const o = R(e, t, s);
            return o.tag = n,
            o
        } catch (n) {
            const s = new r.YAMLReferenceError(t,n.message);
            return s.stack = n.stack,
            e.errors.push(s),
            null
        }
    }
    function B(e, t) {
        const n = {
            before: [],
            after: []
        };
        let s = !1
          , i = !1;
        const o = (e=>{
            if (!e)
                return !1;
            const {type: t} = e;
            return t === r.Type.MAP_KEY || t === r.Type.MAP_VALUE || t === r.Type.SEQ_ITEM
        }
        )(t.context.parent) ? t.context.parent.props.concat(t.props) : t.props;
        for (const {start: a, end: c} of o)
            switch (t.context.src[a]) {
            case r.Char.COMMENT:
                {
                    if (!t.commentHasRequiredWhitespace(a)) {
                        const n = "Comments must be separated from other tokens by white space characters";
                        e.push(new r.YAMLSemanticError(t,n))
                    }
                    const {header: s, valueRange: i} = t;
                    (i && (a > i.start || s && a > s.start) ? n.after : n.before).push(t.context.src.slice(a + 1, c));
                    break
                }
            case r.Char.ANCHOR:
                if (s) {
                    const n = "A node can have at most one anchor";
                    e.push(new r.YAMLSemanticError(t,n))
                }
                s = !0;
                break;
            case r.Char.TAG:
                if (i) {
                    const n = "A node can have at most one tag";
                    e.push(new r.YAMLSemanticError(t,n))
                }
                i = !0
            }
        return {
            comments: n,
            hasAnchor: s,
            hasTag: i
        }
    }
    function Y(e, t) {
        if (!t)
            return null;
        t.error && e.errors.push(t.error);
        const {comments: n, hasAnchor: s, hasTag: i} = B(e.errors, t);
        if (s) {
            const {anchors: n} = e
              , r = t.anchor
              , s = n.getNode(r);
            s && (n.map[n.newName(r)] = s),
            n.map[r] = t
        }
        if (t.type === r.Type.ALIAS && (s || i)) {
            const n = "An alias node must not specify any properties";
            e.errors.push(new r.YAMLSemanticError(t,n))
        }
        const o = function(e, t) {
            const {anchors: n, errors: s, schema: i} = e;
            if (t.type === r.Type.ALIAS) {
                const e = t.rawValue
                  , i = n.getNode(e);
                if (!i) {
                    const n = "Aliased anchor not found: " + e;
                    return s.push(new r.YAMLReferenceError(t,n)),
                    null
                }
                const o = new g(i);
                return n._cstAliases.push(o),
                o
            }
            const o = P(e, t);
            if (o)
                return $(e, t, o);
            if (t.type !== r.Type.PLAIN) {
                const e = `Failed to resolve ${t.type} node here`;
                return s.push(new r.YAMLSyntaxError(t,e)),
                null
            }
            try {
                return w(C(e, t), i.tags, i.tags.scalarFallback)
            } catch (e) {
                return e.source || (e.source = t),
                s.push(e),
                null
            }
        }(e, t);
        if (o) {
            o.range = [t.range.start, t.range.end],
            e.options.keepCstNodes && (o.cstNode = t),
            e.options.keepNodeTypes && (o.type = t.type);
            const r = n.before.join("\n");
            r && (o.commentBefore = o.commentBefore ? `${o.commentBefore}\n${r}` : r);
            const s = n.after.join("\n");
            s && (o.comment = o.comment ? `${o.comment}\n${s}` : s)
        }
        return t.resolved = o
    }
    function F(e, t) {
        if (!(({context: {lineStart: e, node: t, src: n}, props: s})=>{
            if (0 === s.length)
                return !1;
            const {start: i} = s[0];
            if (t && i > t.valueRange.start)
                return !1;
            if (n[i] !== r.Char.COMMENT)
                return !1;
            for (let t = e; t < i; ++t)
                if ("\n" === n[t])
                    return !1;
            return !0
        }
        )(e))
            return;
        const n = e.getPropValue(0, r.Char.COMMENT, !0);
        let s = !1;
        const i = t.value.commentBefore;
        if (i && i.startsWith(n))
            t.value.commentBefore = i.substr(n.length + 1),
            s = !0;
        else {
            const r = t.value.comment;
            !e.node && r && r.startsWith(n) && (t.value.comment = r.substr(n.length + 1),
            s = !0)
        }
        s && (t.comment = n)
    }
    t.Alias = g,
    t.Collection = u,
    t.Merge = v,
    t.Node = i,
    t.Pair = d,
    t.Scalar = a,
    t.YAMLMap = y,
    t.YAMLSeq = h,
    t.addComment = s,
    t.binaryOptions = S,
    t.boolOptions = {
        trueStr: "true",
        falseStr: "false"
    },
    t.findPair = m,
    t.intOptions = {
        asBigInt: !1
    },
    t.isEmptyPath = l,
    t.nullOptions = {
        nullStr: "null"
    },
    t.resolveMap = function(e, t) {
        if (t.type !== r.Type.MAP && t.type !== r.Type.FLOW_MAP) {
            const n = `A ${t.type} node cannot be resolved as a mapping`;
            return e.errors.push(new r.YAMLSyntaxError(t,n)),
            null
        }
        const {comments: n, items: s} = t.type === r.Type.FLOW_MAP ? function(e, t) {
            const n = []
              , s = [];
            let i = void 0
              , o = !1
              , a = "{";
            for (let c = 0; c < t.items.length; ++c) {
                const l = t.items[c];
                if ("string" == typeof l.char) {
                    const {char: n, offset: u} = l;
                    if ("?" === n && void 0 === i && !o) {
                        o = !0,
                        a = ":";
                        continue
                    }
                    if (":" === n) {
                        if (void 0 === i && (i = null),
                        ":" === a) {
                            a = ",";
                            continue
                        }
                    } else if (o && (void 0 === i && "," !== n && (i = null),
                    o = !1),
                    void 0 !== i && (s.push(new d(i)),
                    i = void 0,
                    "," === n)) {
                        a = ":";
                        continue
                    }
                    if ("}" === n) {
                        if (c === t.items.length - 1)
                            continue
                    } else if (n === a) {
                        a = ":";
                        continue
                    }
                    const f = "Flow map contains an unexpected " + n
                      , h = new r.YAMLSyntaxError(t,f);
                    h.offset = u,
                    e.errors.push(h)
                } else
                    l.type === r.Type.BLANK_LINE ? n.push({
                        afterKey: !!i,
                        before: s.length
                    }) : l.type === r.Type.COMMENT ? (k(e.errors, l),
                    n.push({
                        afterKey: !!i,
                        before: s.length,
                        comment: l.comment
                    })) : void 0 === i ? ("," === a && e.errors.push(new r.YAMLSemanticError(l,"Separator , missing in flow map")),
                    i = Y(e, l)) : ("," !== a && e.errors.push(new r.YAMLSemanticError(l,"Indicator : missing in flow map entry")),
                    s.push(new d(i,Y(e, l))),
                    i = void 0,
                    o = !1)
            }
            x(e.errors, t),
            void 0 !== i && s.push(new d(i));
            return {
                comments: n,
                items: s
            }
        }(e, t) : function(e, t) {
            const n = []
              , s = [];
            let i = void 0
              , o = null;
            for (let a = 0; a < t.items.length; ++a) {
                const c = t.items[a];
                switch (c.type) {
                case r.Type.BLANK_LINE:
                    n.push({
                        afterKey: !!i,
                        before: s.length
                    });
                    break;
                case r.Type.COMMENT:
                    n.push({
                        afterKey: !!i,
                        before: s.length,
                        comment: c.comment
                    });
                    break;
                case r.Type.MAP_KEY:
                    void 0 !== i && s.push(new d(i)),
                    c.error && e.errors.push(c.error),
                    i = Y(e, c.node),
                    o = null;
                    break;
                case r.Type.MAP_VALUE:
                    {
                        if (void 0 === i && (i = null),
                        c.error && e.errors.push(c.error),
                        !c.context.atLineStart && c.node && c.node.type === r.Type.MAP && !c.node.context.atLineStart) {
                            const t = "Nested mappings are not allowed in compact mappings";
                            e.errors.push(new r.YAMLSemanticError(c.node,t))
                        }
                        let n = c.node;
                        if (!n && c.props.length > 0) {
                            n = new r.PlainValue(r.Type.PLAIN,[]),
                            n.context = {
                                parent: c,
                                src: c.context.src
                            };
                            const e = c.range.start + 1;
                            if (n.range = {
                                start: e,
                                end: e
                            },
                            n.valueRange = {
                                start: e,
                                end: e
                            },
                            "number" == typeof c.range.origStart) {
                                const e = c.range.origStart + 1;
                                n.range.origStart = n.range.origEnd = e,
                                n.valueRange.origStart = n.valueRange.origEnd = e
                            }
                        }
                        const a = new d(i,Y(e, n));
                        F(c, a),
                        s.push(a),
                        i && "number" == typeof o && c.range.start > o + 1024 && e.errors.push(I(t, i)),
                        i = void 0,
                        o = null
                    }
                    break;
                default:
                    void 0 !== i && s.push(new d(i)),
                    i = Y(e, c),
                    o = c.range.start,
                    c.error && e.errors.push(c.error);
                    e: for (let n = a + 1; ; ++n) {
                        const s = t.items[n];
                        switch (s && s.type) {
                        case r.Type.BLANK_LINE:
                        case r.Type.COMMENT:
                            continue e;
                        case r.Type.MAP_VALUE:
                            break e;
                        default:
                            {
                                const t = "Implicit map keys need to be followed by map values";
                                e.errors.push(new r.YAMLSemanticError(c,t));
                                break e
                            }
                        }
                    }
                    if (c.valueRangeContainsNewline) {
                        const t = "Implicit map keys need to be on a single line";
                        e.errors.push(new r.YAMLSemanticError(c,t))
                    }
                }
            }
            void 0 !== i && s.push(new d(i));
            return {
                comments: n,
                items: s
            }
        }(e, t)
          , i = new y;
        i.items = s,
        _(i, n);
        let o = !1;
        for (let n = 0; n < s.length; ++n) {
            const {key: i} = s[n];
            if (i instanceof u && (o = !0),
            e.schema.merge && i && "<<" === i.value) {
                s[n] = new v(s[n]);
                const i = s[n].value.items;
                let o = null;
                i.some(e=>{
                    if (e instanceof g) {
                        const {type: t} = e.source;
                        return t !== r.Type.MAP && t !== r.Type.FLOW_MAP && (o = "Merge nodes aliases can only point to maps")
                    }
                    return o = "Merge nodes can only have Alias nodes as values"
                }
                ),
                o && e.errors.push(new r.YAMLSemanticError(t,o))
            } else
                for (let o = n + 1; o < s.length; ++o) {
                    const {key: n} = s[o];
                    if (i === n || i && n && Object.prototype.hasOwnProperty.call(i, "value") && i.value === n.value) {
                        const n = `Map keys must be unique; "${i}" is repeated`;
                        e.errors.push(new r.YAMLSemanticError(t,n));
                        break
                    }
                }
        }
        if (o && !e.options.mapAsMap) {
            const n = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
            e.warnings.push(new r.YAMLWarning(t,n))
        }
        return t.resolved = i,
        i
    }
    ,
    t.resolveNode = Y,
    t.resolveSeq = function(e, t) {
        if (t.type !== r.Type.SEQ && t.type !== r.Type.FLOW_SEQ) {
            const n = `A ${t.type} node cannot be resolved as a sequence`;
            return e.errors.push(new r.YAMLSyntaxError(t,n)),
            null
        }
        const {comments: n, items: s} = t.type === r.Type.FLOW_SEQ ? function(e, t) {
            const n = []
              , s = [];
            let i = !1
              , o = void 0
              , a = null
              , c = "["
              , l = null;
            for (let u = 0; u < t.items.length; ++u) {
                const f = t.items[u];
                if ("string" == typeof f.char) {
                    const {char: n, offset: h} = f;
                    if (":" === n || !i && void 0 === o || (i && void 0 === o && (o = c ? s.pop() : null),
                    s.push(new d(o)),
                    i = !1,
                    o = void 0,
                    a = null),
                    n === c)
                        c = null;
                    else if (c || "?" !== n) {
                        if ("[" !== c && ":" === n && void 0 === o) {
                            if ("," === c) {
                                if (o = s.pop(),
                                o instanceof d) {
                                    const n = "Chaining flow sequence pairs is invalid"
                                      , s = new r.YAMLSemanticError(t,n);
                                    s.offset = h,
                                    e.errors.push(s)
                                }
                                if (!i && "number" == typeof a) {
                                    const n = f.range ? f.range.start : f.offset;
                                    n > a + 1024 && e.errors.push(I(t, o));
                                    const {src: s} = l.context;
                                    for (let t = a; t < n; ++t)
                                        if ("\n" === s[t]) {
                                            const t = "Implicit keys of flow sequence pairs need to be on a single line";
                                            e.errors.push(new r.YAMLSemanticError(l,t));
                                            break
                                        }
                                }
                            } else
                                o = null;
                            a = null,
                            i = !1,
                            c = null
                        } else if ("[" === c || "]" !== n || u < t.items.length - 1) {
                            const s = "Flow sequence contains an unexpected " + n
                              , i = new r.YAMLSyntaxError(t,s);
                            i.offset = h,
                            e.errors.push(i)
                        }
                    } else
                        i = !0
                } else if (f.type === r.Type.BLANK_LINE)
                    n.push({
                        before: s.length
                    });
                else if (f.type === r.Type.COMMENT)
                    k(e.errors, f),
                    n.push({
                        comment: f.comment,
                        before: s.length
                    });
                else {
                    if (c) {
                        const t = `Expected a ${c} in flow sequence`;
                        e.errors.push(new r.YAMLSemanticError(f,t))
                    }
                    const t = Y(e, f);
                    void 0 === o ? (s.push(t),
                    l = f) : (s.push(new d(o,t)),
                    o = void 0),
                    a = f.range.start,
                    c = ","
                }
            }
            x(e.errors, t),
            void 0 !== o && s.push(new d(o));
            return {
                comments: n,
                items: s
            }
        }(e, t) : function(e, t) {
            const n = []
              , s = [];
            for (let i = 0; i < t.items.length; ++i) {
                const o = t.items[i];
                switch (o.type) {
                case r.Type.BLANK_LINE:
                    n.push({
                        before: s.length
                    });
                    break;
                case r.Type.COMMENT:
                    n.push({
                        comment: o.comment,
                        before: s.length
                    });
                    break;
                case r.Type.SEQ_ITEM:
                    if (o.error && e.errors.push(o.error),
                    s.push(Y(e, o.node)),
                    o.hasProps) {
                        const t = "Sequence items cannot have tags or anchors before the - indicator";
                        e.errors.push(new r.YAMLSemanticError(o,t))
                    }
                    break;
                default:
                    o.error && e.errors.push(o.error),
                    e.errors.push(new r.YAMLSyntaxError(o,`Unexpected ${o.type} node in sequence`))
                }
            }
            return {
                comments: n,
                items: s
            }
        }(e, t)
          , i = new h;
        if (i.items = s,
        _(i, n),
        !e.options.mapAsMap && s.some(e=>e instanceof d && e.key instanceof u)) {
            const n = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
            e.warnings.push(new r.YAMLWarning(t,n))
        }
        return t.resolved = i,
        i
    }
    ,
    t.resolveString = C,
    t.strOptions = b,
    t.stringifyNumber = function({format: e, minFractionDigits: t, tag: n, value: r}) {
        if ("bigint" == typeof r)
            return String(r);
        if (!isFinite(r))
            return isNaN(r) ? ".nan" : r < 0 ? "-.inf" : ".inf";
        let s = JSON.stringify(r);
        if (!e && t && (!n || "tag:yaml.org,2002:float" === n) && /^\d/.test(s)) {
            let e = s.indexOf(".");
            e < 0 && (e = s.length,
            s += ".");
            let n = t - (s.length - e - 1);
            for (; n-- > 0; )
                s += "0"
        }
        return s
    }
    ,
    t.stringifyString = function(e, t, n, s) {
        const {defaultType: i} = b
          , {implicitKey: o, inFlow: a} = t;
        let {type: c, value: l} = e;
        "string" != typeof l && (l = String(l),
        e = Object.assign({}, e, {
            value: l
        }));
        const u = i=>{
            switch (i) {
            case r.Type.BLOCK_FOLDED:
            case r.Type.BLOCK_LITERAL:
                return T(e, t, n, s);
            case r.Type.QUOTE_DOUBLE:
                return L(l, t);
            case r.Type.QUOTE_SINGLE:
                return A(l, t);
            case r.Type.PLAIN:
                return function(e, t, n, s) {
                    const {comment: i, type: o, value: a} = e
                      , {actualString: c, implicitKey: l, indent: u, inFlow: f} = t;
                    if (l && /[\n[\]{},]/.test(a) || f && /[[\]{},]/.test(a))
                        return L(a, t);
                    if (!a || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(a))
                        return l || f || -1 === a.indexOf("\n") ? -1 !== a.indexOf('"') && -1 === a.indexOf("'") ? A(a, t) : L(a, t) : T(e, t, n, s);
                    if (!l && !f && o !== r.Type.PLAIN && -1 !== a.indexOf("\n"))
                        return T(e, t, n, s);
                    if ("" === u && M(a))
                        return t.forceBlockIndent = !0,
                        T(e, t, n, s);
                    const h = a.replace(/\n+/g, "$&\n" + u);
                    if (c) {
                        const {tags: e} = t.doc.schema;
                        if ("string" != typeof w(h, e, e.scalarFallback).value)
                            return L(a, t)
                    }
                    const d = l ? h : O(h, u, "flow", N(t));
                    return !i || f || -1 === d.indexOf("\n") && -1 === i.indexOf("\n") ? d : (n && n(),
                    function(e, t, n) {
                        return n ? `#${n.replace(/[\s\S]^/gm, `$&${t}#`)}\n${t}${e}` : e
                    }(d, u, i))
                }(e, t, n, s);
            default:
                return null
            }
        }
        ;
        c !== r.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(l) ? c = r.Type.QUOTE_DOUBLE : !o && !a || c !== r.Type.BLOCK_FOLDED && c !== r.Type.BLOCK_LITERAL || (c = r.Type.QUOTE_DOUBLE);
        let f = u(c);
        if (null === f && (f = u(i),
        null === f))
            throw new Error("Unsupported default string type " + i);
        return f
    }
    ,
    t.toJSON = o
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = joplin
}
, function(e, t, n) {
    "use strict";
    var r = n(0)
      , s = n(1)
      , i = n(4);
    const o = {
        createNode: function(e, t, n) {
            const r = new s.YAMLMap(e);
            if (t instanceof Map)
                for (const [s,i] of t)
                    r.items.push(e.createPair(s, i, n));
            else if (t && "object" == typeof t)
                for (const s of Object.keys(t))
                    r.items.push(e.createPair(s, t[s], n));
            return "function" == typeof e.sortMapEntries && r.items.sort(e.sortMapEntries),
            r
        },
        default: !0,
        nodeClass: s.YAMLMap,
        tag: "tag:yaml.org,2002:map",
        resolve: s.resolveMap
    };
    const a = {
        createNode: function(e, t, n) {
            const r = new s.YAMLSeq(e);
            if (t && t[Symbol.iterator])
                for (const s of t) {
                    const t = e.createNode(s, n.wrapScalars, null, n);
                    r.items.push(t)
                }
            return r
        },
        default: !0,
        nodeClass: s.YAMLSeq,
        tag: "tag:yaml.org,2002:seq",
        resolve: s.resolveSeq
    }
      , c = {
        identify: e=>"string" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:str",
        resolve: s.resolveString,
        stringify: (e,t,n,r)=>(t = Object.assign({
            actualString: !0
        }, t),
        s.stringifyString(e, t, n, r)),
        options: s.strOptions
    }
      , l = [o, a, c]
      , u = e=>"bigint" == typeof e || Number.isInteger(e)
      , f = (e,t,n)=>s.intOptions.asBigInt ? BigInt(e) : parseInt(t, n);
    function h(e, t, n) {
        const {value: r} = e;
        return u(r) && r >= 0 ? n + r.toString(t) : s.stringifyNumber(e)
    }
    const d = {
        identify: e=>null == e,
        createNode: (e,t,n)=>n.wrapScalars ? new s.Scalar(null) : null,
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^(?:~|[Nn]ull|NULL)?$/,
        resolve: ()=>null,
        options: s.nullOptions,
        stringify: ()=>s.nullOptions.nullStr
    }
      , p = {
        identify: e=>"boolean" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
        resolve: e=>"t" === e[0] || "T" === e[0],
        options: s.boolOptions,
        stringify: ({value: e})=>e ? s.boolOptions.trueStr : s.boolOptions.falseStr
    }
      , g = {
        identify: e=>u(e) && e >= 0,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^0o([0-7]+)$/,
        resolve: (e,t)=>f(e, t, 8),
        options: s.intOptions,
        stringify: e=>h(e, 8, "0o")
    }
      , m = {
        identify: u,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^[-+]?[0-9]+$/,
        resolve: e=>f(e, e, 10),
        options: s.intOptions,
        stringify: s.stringifyNumber
    }
      , y = {
        identify: e=>u(e) && e >= 0,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^0x([0-9a-fA-F]+)$/,
        resolve: (e,t)=>f(e, t, 16),
        options: s.intOptions,
        stringify: e=>h(e, 16, "0x")
    }
      , v = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.inf|(\.nan))$/i,
        resolve: (e,t)=>t ? NaN : "-" === e[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
        stringify: s.stringifyNumber
    }
      , S = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
        resolve: e=>parseFloat(e),
        stringify: ({value: e})=>Number(e).toExponential()
    }
      , b = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
        resolve(e, t, n) {
            const r = t || n
              , i = new s.Scalar(parseFloat(e));
            return r && "0" === r[r.length - 1] && (i.minFractionDigits = r.length),
            i
        },
        stringify: s.stringifyNumber
    }
      , w = l.concat([d, p, g, m, y, v, S, b])
      , E = e=>"bigint" == typeof e || Number.isInteger(e)
      , O = ({value: e})=>JSON.stringify(e)
      , N = [o, a, {
        identify: e=>"string" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:str",
        resolve: s.resolveString,
        stringify: O
    }, {
        identify: e=>null == e,
        createNode: (e,t,n)=>n.wrapScalars ? new s.Scalar(null) : null,
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: ()=>null,
        stringify: O
    }, {
        identify: e=>"boolean" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: e=>"true" === e,
        stringify: O
    }, {
        identify: E,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: e=>s.intOptions.asBigInt ? BigInt(e) : parseInt(e, 10),
        stringify: ({value: e})=>E(e) ? e.toString() : JSON.stringify(e)
    }, {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: e=>parseFloat(e),
        stringify: O
    }];
    N.scalarFallback = e=>{
        throw new SyntaxError("Unresolved plain scalar " + JSON.stringify(e))
    }
    ;
    const M = ({value: e})=>e ? s.boolOptions.trueStr : s.boolOptions.falseStr
      , L = e=>"bigint" == typeof e || Number.isInteger(e);
    function A(e, t, n) {
        let r = t.replace(/_/g, "");
        if (s.intOptions.asBigInt) {
            switch (n) {
            case 2:
                r = "0b" + r;
                break;
            case 8:
                r = "0o" + r;
                break;
            case 16:
                r = "0x" + r
            }
            const t = BigInt(r);
            return "-" === e ? BigInt(-1) * t : t
        }
        const i = parseInt(r, n);
        return "-" === e ? -1 * i : i
    }
    function T(e, t, n) {
        const {value: r} = e;
        if (L(r)) {
            const e = r.toString(t);
            return r < 0 ? "-" + n + e.substr(1) : n + e
        }
        return s.stringifyNumber(e)
    }
    const x = l.concat([{
        identify: e=>null == e,
        createNode: (e,t,n)=>n.wrapScalars ? new s.Scalar(null) : null,
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^(?:~|[Nn]ull|NULL)?$/,
        resolve: ()=>null,
        options: s.nullOptions,
        stringify: ()=>s.nullOptions.nullStr
    }, {
        identify: e=>"boolean" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
        resolve: ()=>!0,
        options: s.boolOptions,
        stringify: M
    }, {
        identify: e=>"boolean" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
        resolve: ()=>!1,
        options: s.boolOptions,
        stringify: M
    }, {
        identify: L,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "BIN",
        test: /^([-+]?)0b([0-1_]+)$/,
        resolve: (e,t,n)=>A(t, n, 2),
        stringify: e=>T(e, 2, "0b")
    }, {
        identify: L,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^([-+]?)0([0-7_]+)$/,
        resolve: (e,t,n)=>A(t, n, 8),
        stringify: e=>T(e, 8, "0")
    }, {
        identify: L,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^([-+]?)([0-9][0-9_]*)$/,
        resolve: (e,t,n)=>A(t, n, 10),
        stringify: s.stringifyNumber
    }, {
        identify: L,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
        resolve: (e,t,n)=>A(t, n, 16),
        stringify: e=>T(e, 16, "0x")
    }, {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.inf|(\.nan))$/i,
        resolve: (e,t)=>t ? NaN : "-" === e[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
        stringify: s.stringifyNumber
    }, {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
        resolve: e=>parseFloat(e.replace(/_/g, "")),
        stringify: ({value: e})=>Number(e).toExponential()
    }, {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
        resolve(e, t) {
            const n = new s.Scalar(parseFloat(e.replace(/_/g, "")));
            if (t) {
                const e = t.replace(/_/g, "");
                "0" === e[e.length - 1] && (n.minFractionDigits = e.length)
            }
            return n
        },
        stringify: s.stringifyNumber
    }], i.binary, i.omap, i.pairs, i.set, i.intTime, i.floatTime, i.timestamp)
      , k = {
        core: w,
        failsafe: l,
        json: N,
        yaml11: x
    }
      , I = {
        binary: i.binary,
        bool: p,
        float: b,
        floatExp: S,
        floatNaN: v,
        floatTime: i.floatTime,
        int: m,
        intHex: y,
        intOct: g,
        intTime: i.intTime,
        map: o,
        null: d,
        omap: i.omap,
        pairs: i.pairs,
        seq: a,
        set: i.set,
        timestamp: i.timestamp
    };
    function _(e, t, n) {
        if (e instanceof s.Node)
            return e;
        const {defaultPrefix: r, onTagObj: i, prevObjects: c, schema: l, wrapScalars: u} = n;
        t && t.startsWith("!!") && (t = r + t.slice(2));
        let f = function(e, t, n) {
            if (t) {
                const e = n.filter(e=>e.tag === t)
                  , r = e.find(e=>!e.format) || e[0];
                if (!r)
                    throw new Error(`Tag ${t} not found`);
                return r
            }
            return n.find(t=>(t.identify && t.identify(e) || t.class && e instanceof t.class) && !t.format)
        }(e, t, l.tags);
        if (!f) {
            if ("function" == typeof e.toJSON && (e = e.toJSON()),
            !e || "object" != typeof e)
                return u ? new s.Scalar(e) : e;
            f = e instanceof Map ? o : e[Symbol.iterator] ? a : o
        }
        i && (i(f),
        delete n.onTagObj);
        const h = {
            value: void 0,
            node: void 0
        };
        if (e && "object" == typeof e && c) {
            const t = c.get(e);
            if (t) {
                const e = new s.Alias(t);
                return n.aliasNodes.push(e),
                e
            }
            h.value = e,
            c.set(e, h)
        }
        return h.node = f.createNode ? f.createNode(n.schema, e, n) : u ? new s.Scalar(e) : e,
        t && h.node instanceof s.Node && (h.node.tag = t),
        h.node
    }
    const C = (e,t)=>e.key < t.key ? -1 : e.key > t.key ? 1 : 0;
    class P {
        constructor({customTags: e, merge: t, schema: n, sortMapEntries: r, tags: s}) {
            this.merge = !!t,
            this.name = n,
            this.sortMapEntries = !0 === r ? C : r || null,
            !e && s && i.warnOptionDeprecation("tags", "customTags"),
            this.tags = function(e, t, n, r) {
                let s = e[r.replace(/\W/g, "")];
                if (!s) {
                    const t = Object.keys(e).map(e=>JSON.stringify(e)).join(", ");
                    throw new Error(`Unknown schema "${r}"; use one of ${t}`)
                }
                if (Array.isArray(n))
                    for (const e of n)
                        s = s.concat(e);
                else
                    "function" == typeof n && (s = n(s.slice()));
                for (let e = 0; e < s.length; ++e) {
                    const n = s[e];
                    if ("string" == typeof n) {
                        const r = t[n];
                        if (!r) {
                            const e = Object.keys(t).map(e=>JSON.stringify(e)).join(", ");
                            throw new Error(`Unknown custom tag "${n}"; use one of ${e}`)
                        }
                        s[e] = r
                    }
                }
                return s
            }(k, I, e || s, n)
        }
        createNode(e, t, n, r) {
            const s = {
                defaultPrefix: P.defaultPrefix,
                schema: this,
                wrapScalars: t
            };
            return _(e, n, r ? Object.assign(r, s) : s)
        }
        createPair(e, t, n) {
            n || (n = {
                wrapScalars: !0
            });
            const r = this.createNode(e, n.wrapScalars, null, n)
              , i = this.createNode(t, n.wrapScalars, null, n);
            return new s.Pair(r,i)
        }
    }
    r._defineProperty(P, "defaultPrefix", r.defaultTagPrefix),
    r._defineProperty(P, "defaultTags", r.defaultTags),
    t.Schema = P
}
, function(e, t, n) {
    "use strict";
    var r = n(0)
      , s = n(1);
    const i = {
        identify: e=>e instanceof Uint8Array,
        default: !1,
        tag: "tag:yaml.org,2002:binary",
        resolve: (e,t)=>{
            const n = s.resolveString(e, t);
            if ("function" == typeof Buffer)
                return Buffer.from(n, "base64");
            if ("function" == typeof atob) {
                const e = atob(n.replace(/[\n\r]/g, ""))
                  , t = new Uint8Array(e.length);
                for (let n = 0; n < e.length; ++n)
                    t[n] = e.charCodeAt(n);
                return t
            }
            {
                const n = "This environment does not support reading binary tags; either Buffer or atob is required";
                return e.errors.push(new r.YAMLReferenceError(t,n)),
                null
            }
        }
        ,
        options: s.binaryOptions,
        stringify: ({comment: e, type: t, value: n},i,o,a)=>{
            let c;
            if ("function" == typeof Buffer)
                c = n instanceof Buffer ? n.toString("base64") : Buffer.from(n.buffer).toString("base64");
            else {
                if ("function" != typeof btoa)
                    throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
                {
                    let e = "";
                    for (let t = 0; t < n.length; ++t)
                        e += String.fromCharCode(n[t]);
                    c = btoa(e)
                }
            }
            if (t || (t = s.binaryOptions.defaultType),
            t === r.Type.QUOTE_DOUBLE)
                n = c;
            else {
                const {lineWidth: e} = s.binaryOptions
                  , i = Math.ceil(c.length / e)
                  , o = new Array(i);
                for (let t = 0, n = 0; t < i; ++t,
                n += e)
                    o[t] = c.substr(n, e);
                n = o.join(t === r.Type.BLOCK_LITERAL ? "\n" : " ")
            }
            return s.stringifyString({
                comment: e,
                type: t,
                value: n
            }, i, o, a)
        }
    };
    function o(e, t) {
        const n = s.resolveSeq(e, t);
        for (let e = 0; e < n.items.length; ++e) {
            let i = n.items[e];
            if (!(i instanceof s.Pair)) {
                if (i instanceof s.YAMLMap) {
                    if (i.items.length > 1) {
                        const e = "Each pair must have its own sequence indicator";
                        throw new r.YAMLSemanticError(t,e)
                    }
                    const e = i.items[0] || new s.Pair;
                    i.commentBefore && (e.commentBefore = e.commentBefore ? `${i.commentBefore}\n${e.commentBefore}` : i.commentBefore),
                    i.comment && (e.comment = e.comment ? `${i.comment}\n${e.comment}` : i.comment),
                    i = e
                }
                n.items[e] = i instanceof s.Pair ? i : new s.Pair(i)
            }
        }
        return n
    }
    function a(e, t, n) {
        const r = new s.YAMLSeq(e);
        r.tag = "tag:yaml.org,2002:pairs";
        for (const s of t) {
            let t, i;
            if (Array.isArray(s)) {
                if (2 !== s.length)
                    throw new TypeError("Expected [key, value] tuple: " + s);
                t = s[0],
                i = s[1]
            } else if (s && s instanceof Object) {
                const e = Object.keys(s);
                if (1 !== e.length)
                    throw new TypeError("Expected { key: value } tuple: " + s);
                t = e[0],
                i = s[t]
            } else
                t = s;
            const o = e.createPair(t, i, n);
            r.items.push(o)
        }
        return r
    }
    const c = {
        default: !1,
        tag: "tag:yaml.org,2002:pairs",
        resolve: o,
        createNode: a
    };
    class l extends s.YAMLSeq {
        constructor() {
            super(),
            r._defineProperty(this, "add", s.YAMLMap.prototype.add.bind(this)),
            r._defineProperty(this, "delete", s.YAMLMap.prototype.delete.bind(this)),
            r._defineProperty(this, "get", s.YAMLMap.prototype.get.bind(this)),
            r._defineProperty(this, "has", s.YAMLMap.prototype.has.bind(this)),
            r._defineProperty(this, "set", s.YAMLMap.prototype.set.bind(this)),
            this.tag = l.tag
        }
        toJSON(e, t) {
            const n = new Map;
            t && t.onCreate && t.onCreate(n);
            for (const e of this.items) {
                let r, i;
                if (e instanceof s.Pair ? (r = s.toJSON(e.key, "", t),
                i = s.toJSON(e.value, r, t)) : r = s.toJSON(e, "", t),
                n.has(r))
                    throw new Error("Ordered maps must not include duplicate keys");
                n.set(r, i)
            }
            return n
        }
    }
    r._defineProperty(l, "tag", "tag:yaml.org,2002:omap");
    const u = {
        identify: e=>e instanceof Map,
        nodeClass: l,
        default: !1,
        tag: "tag:yaml.org,2002:omap",
        resolve: function(e, t) {
            const n = o(e, t)
              , i = [];
            for (const {key: e} of n.items)
                if (e instanceof s.Scalar) {
                    if (i.includes(e.value)) {
                        const e = "Ordered maps must not include duplicate keys";
                        throw new r.YAMLSemanticError(t,e)
                    }
                    i.push(e.value)
                }
            return Object.assign(new l, n)
        },
        createNode: function(e, t, n) {
            const r = a(e, t, n)
              , s = new l;
            return s.items = r.items,
            s
        }
    };
    class f extends s.YAMLMap {
        constructor() {
            super(),
            this.tag = f.tag
        }
        add(e) {
            const t = e instanceof s.Pair ? e : new s.Pair(e);
            s.findPair(this.items, t.key) || this.items.push(t)
        }
        get(e, t) {
            const n = s.findPair(this.items, e);
            return !t && n instanceof s.Pair ? n.key instanceof s.Scalar ? n.key.value : n.key : n
        }
        set(e, t) {
            if ("boolean" != typeof t)
                throw new Error("Expected boolean value for set(key, value) in a YAML set, not " + typeof t);
            const n = s.findPair(this.items, e);
            n && !t ? this.items.splice(this.items.indexOf(n), 1) : !n && t && this.items.push(new s.Pair(e))
        }
        toJSON(e, t) {
            return super.toJSON(e, t, Set)
        }
        toString(e, t, n) {
            if (!e)
                return JSON.stringify(this);
            if (this.hasAllNullValues())
                return super.toString(e, t, n);
            throw new Error("Set items must all have null values")
        }
    }
    r._defineProperty(f, "tag", "tag:yaml.org,2002:set");
    const h = {
        identify: e=>e instanceof Set,
        nodeClass: f,
        default: !1,
        tag: "tag:yaml.org,2002:set",
        resolve: function(e, t) {
            const n = s.resolveMap(e, t);
            if (!n.hasAllNullValues())
                throw new r.YAMLSemanticError(t,"Set items must all have null values");
            return Object.assign(new f, n)
        },
        createNode: function(e, t, n) {
            const r = new f;
            for (const s of t)
                r.items.push(e.createPair(s, null, n));
            return r
        }
    }
      , d = (e,t)=>{
        const n = t.split(":").reduce((e,t)=>60 * e + Number(t), 0);
        return "-" === e ? -n : n
    }
      , p = ({value: e})=>{
        if (isNaN(e) || !isFinite(e))
            return s.stringifyNumber(e);
        let t = "";
        e < 0 && (t = "-",
        e = Math.abs(e));
        const n = [e % 60];
        return e < 60 ? n.unshift(0) : (e = Math.round((e - n[0]) / 60),
        n.unshift(e % 60),
        e >= 60 && (e = Math.round((e - n[0]) / 60),
        n.unshift(e))),
        t + n.map(e=>e < 10 ? "0" + String(e) : String(e)).join(":").replace(/000000\d*$/, "")
    }
      , g = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "TIME",
        test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
        resolve: (e,t,n)=>d(t, n.replace(/_/g, "")),
        stringify: p
    }
      , m = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "TIME",
        test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
        resolve: (e,t,n)=>d(t, n.replace(/_/g, "")),
        stringify: p
    }
      , y = {
        identify: e=>e instanceof Date,
        default: !0,
        tag: "tag:yaml.org,2002:timestamp",
        test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
        resolve: (e,t,n,r,s,i,o,a,c)=>{
            a && (a = (a + "00").substr(1, 3));
            let l = Date.UTC(t, n - 1, r, s || 0, i || 0, o || 0, a || 0);
            if (c && "Z" !== c) {
                let e = d(c[0], c.slice(1));
                Math.abs(e) < 30 && (e *= 60),
                l -= 6e4 * e
            }
            return new Date(l)
        }
        ,
        stringify: ({value: e})=>e.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    function v(e) {
        const t = "undefined" != typeof process && process.env || {};
        return e ? "undefined" != typeof YAML_SILENCE_DEPRECATION_WARNINGS ? !YAML_SILENCE_DEPRECATION_WARNINGS : !t.YAML_SILENCE_DEPRECATION_WARNINGS : "undefined" != typeof YAML_SILENCE_WARNINGS ? !YAML_SILENCE_WARNINGS : !t.YAML_SILENCE_WARNINGS
    }
    function S(e, t) {
        if (v(!1)) {
            const n = "undefined" != typeof process && process.emitWarning;
            n ? n(e, t) : console.warn(t ? `${t}: ${e}` : e)
        }
    }
    const b = {};
    t.binary = i,
    t.floatTime = m,
    t.intTime = g,
    t.omap = u,
    t.pairs = c,
    t.set = h,
    t.timestamp = y,
    t.warn = S,
    t.warnFileDeprecation = function(e) {
        if (v(!0)) {
            S(`The endpoint 'yaml/${e.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/")}' will be removed in a future release.`, "DeprecationWarning")
        }
    }
    ,
    t.warnOptionDeprecation = function(e, t) {
        if (!b[e] && v(!0)) {
            b[e] = !0;
            let n = `The option '${e}' will be removed in a future release`;
            n += t ? `, use '${t}' instead.` : ".",
            S(n, "DeprecationWarning")
        }
    }
}
, function(e, t, n) {
    "use strict";
    var r = this && this.__awaiter || function(e, t, n, r) {
        return new (n || (n = Promise))((function(s, i) {
            function o(e) {
                try {
                    c(r.next(e))
                } catch (e) {
                    i(e)
                }
            }
            function a(e) {
                try {
                    c(r.throw(e))
                } catch (e) {
                    i(e)
                }
            }
            function c(e) {
                var t;
                e.done ? s(e.value) : (t = e.value,
                t instanceof n ? t : new n((function(e) {
                    e(t)
                }
                ))).then(o, a)
            }
            c((r = r.apply(e, t || [])).next())
        }
        ))
    }
    ;
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = n(2)
      , i = n(6)
      , o = n(8)
      , a = n(9);
    s.default.plugins.register({
        onStart: function() {
            return r(this, void 0, void 0, (function*() {
                s.default.commands,
                s.default.data;
                const e = s.default.settings
                  , t = s.default.workspace
                  , n = new i.Settings;
                yield n.register();
                const c = new o.Panel(n);
                yield c.register(),
                e.onChange(e=>r(this, void 0, void 0, (function*() {
                    yield n.read(e),
                    yield c.updateWebview()
                }
                ))),
                t.onNoteSelectionChange(()=>r(this, void 0, void 0, (function*() {
                    try {
                        const e = yield t.selectedNote();
                        let n;
                        if (e) {
                            const t = yield function(e) {
                                return r(this, void 0, void 0, (function*() {
                                    const t = e.body.split("\n");
                                    if (!t.shift().match(/^(---|```yaml|<!--\s*yaml)/i))
                                        return;
                                    const n = [];
                                    for (const e of t) {
                                        if (e.match(/^(---|```|-->)/i))
                                            break;
                                        n.push(e)
                                    }
                                    return n.join("\n")
                                }
                                ))
                            }(e);
                            t && (n = a.parseDocument(t, {
                                mapAsMap: !0,
                                prettyErrors: !0
                            })),
                            console.log("yaml object: " + e.title),
                            console.log("" + a.stringify(n)),
                            console.log(n.size + " "),
                            console.log(n.entries[0].key + ", ")
                        }
                        yield c.updateWebview(n)
                    } catch (e) {
                        console.error("onNoteSelectionChange: " + e)
                    }
                }
                ))),
                yield c.updateWebview()
            }
            ))
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = this && this.__awaiter || function(e, t, n, r) {
        return new (n || (n = Promise))((function(s, i) {
            function o(e) {
                try {
                    c(r.next(e))
                } catch (e) {
                    i(e)
                }
            }
            function a(e) {
                try {
                    c(r.throw(e))
                } catch (e) {
                    i(e)
                }
            }
            function c(e) {
                var t;
                e.done ? s(e.value) : (t = e.value,
                t instanceof n ? t : new n((function(e) {
                    e(t)
                }
                ))).then(o, a)
            }
            c((r = r.apply(e, t || [])).next())
        }
        ))
    }
    ;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.Settings = t.SettingDefaults = void 0;
    const s = n(2)
      , i = n(7);
    var o;
    !function(e) {
        e.Empty = "0",
        e.Default = "default",
        e.FontFamily = "Roboto",
        e.FontSize = "var(--joplin-font-size)",
        e.Background = "var(--joplin-background-color3)",
        e.HoverBackground = "var(--joplin-background-color-hover3)",
        e.Foreground = "var(--joplin-color-faded)",
        e.DividerColor = "var(--joplin-divider-color)"
    }(o = t.SettingDefaults || (t.SettingDefaults = {}));
    t.Settings = class {
        constructor() {
            this._lineHeight = 30,
            this._fontFamily = o.Default,
            this._fontSize = o.Default,
            this._background = o.Default,
            this._hoverBackground = o.Default,
            this._foreground = o.Default,
            this._dividerColor = o.Default,
            this._defaultRegExp = new RegExp(o.Default,"i")
        }
        get lineHeight() {
            return this._lineHeight
        }
        get fontFamily() {
            return this._fontFamily
        }
        get fontSize() {
            return this._fontSize
        }
        get background() {
            return this._background
        }
        get hoverBackground() {
            return this._hoverBackground
        }
        get foreground() {
            return this._foreground
        }
        get dividerColor() {
            return this._dividerColor
        }
        register() {
            return r(this, void 0, void 0, (function*() {
                yield s.default.settings.registerSection("yaml.fm.settings", {
                    label: "YAML Front Matter",
                    iconName: "fas fa-info-circle"
                }),
                yield s.default.settings.registerSetting("lineHeight", {
                    value: this._lineHeight,
                    type: i.SettingItemType.Int,
                    section: "yaml.fm.settings",
                    public: !0,
                    minimum: 20,
                    label: "Line height (px)",
                    description: "Line height of one data entry."
                }),
                yield s.default.settings.registerSetting("fontFamily", {
                    value: this._fontFamily,
                    type: i.SettingItemType.String,
                    section: "yaml.fm.settings",
                    public: !0,
                    advanced: !0,
                    label: "Font family",
                    description: "Font family used in the panel. Font families other than 'default' must be installed on the system. If the font is incorrect or empty, it might default to a generic sans-serif font. (default: Roboto)"
                }),
                yield s.default.settings.registerSetting("fontSize", {
                    value: this._fontSize,
                    type: i.SettingItemType.String,
                    section: "yaml.fm.settings",
                    public: !0,
                    advanced: !0,
                    label: "Font size",
                    description: "Font size used in the panel. Values other than 'default' must be specified in valid CSS syntax, e.g. '13px'. (default: App default font size)"
                }),
                yield s.default.settings.registerSetting("mainBackground", {
                    value: this._background,
                    type: i.SettingItemType.String,
                    section: "yaml.fm.settings",
                    public: !0,
                    advanced: !0,
                    label: "Background color",
                    description: "Main background color of the panel. (default: Note background color)"
                }),
                yield s.default.settings.registerSetting("hoverBackground", {
                    value: this._hoverBackground,
                    type: i.SettingItemType.String,
                    section: "yaml.fm.settings",
                    public: !0,
                    advanced: !0,
                    label: "Hover Background color",
                    description: "Background color used when hovering a data entry. (default: Note list hover color)"
                }),
                yield s.default.settings.registerSetting("mainForeground", {
                    value: this._foreground,
                    type: i.SettingItemType.String,
                    section: "yaml.fm.settings",
                    public: !0,
                    advanced: !0,
                    label: "Foreground color",
                    description: "Foreground color used for text and icons. (default: Note font color)"
                }),
                yield s.default.settings.registerSetting("dividerColor", {
                    value: this._dividerColor,
                    type: i.SettingItemType.String,
                    section: "yaml.fm.settings",
                    public: !0,
                    advanced: !0,
                    label: "Divider color",
                    description: "Color of the divider between the data entries. (default: App default border color)"
                }),
                yield this.read()
            }
            ))
        }
        getOrDefault(e, t, n, i) {
            return r(this, void 0, void 0, (function*() {
                if (!e || e.keys.includes(n)) {
                    const e = yield s.default.settings.value(n);
                    return i && e.match(this._defaultRegExp) ? i : e
                }
                return t
            }
            ))
        }
        read(e) {
            return r(this, void 0, void 0, (function*() {
                this._lineHeight = yield this.getOrDefault(e, this._lineHeight, "lineHeight"),
                this._fontFamily = yield this.getOrDefault(e, this._fontFamily, "fontFamily", o.FontFamily),
                this._fontSize = yield this.getOrDefault(e, this._fontSize, "fontSize", o.FontSize),
                this._background = yield this.getOrDefault(e, this._background, "mainBackground", o.Background),
                this._hoverBackground = yield this.getOrDefault(e, this._hoverBackground, "hoverBackground", o.HoverBackground),
                this._foreground = yield this.getOrDefault(e, this._foreground, "mainForeground", o.Foreground),
                this._dividerColor = yield this.getOrDefault(e, this._dividerColor, "dividerColor", o.DividerColor)
            }
            ))
        }
    }
}
, function(e, t, n) {
    "use strict";
    var r;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.ContentScriptType = t.SettingItemType = t.ToolbarButtonLocation = t.isContextMenuItemLocation = t.MenuItemLocation = t.ImportModuleOutputFormat = t.FileSystemItem = void 0,
    function(e) {
        e.File = "file",
        e.Directory = "directory"
    }(t.FileSystemItem || (t.FileSystemItem = {})),
    function(e) {
        e.Markdown = "md",
        e.Html = "html"
    }(t.ImportModuleOutputFormat || (t.ImportModuleOutputFormat = {})),
    function(e) {
        e.File = "file",
        e.Edit = "edit",
        e.View = "view",
        e.Note = "note",
        e.Tools = "tools",
        e.Help = "help",
        e.Context = "context",
        e.NoteListContextMenu = "noteListContextMenu",
        e.EditorContextMenu = "editorContextMenu",
        e.FolderContextMenu = "folderContextMenu",
        e.TagContextMenu = "tagContextMenu"
    }(r = t.MenuItemLocation || (t.MenuItemLocation = {})),
    t.isContextMenuItemLocation = function(e) {
        return [r.Context, r.NoteListContextMenu, r.EditorContextMenu, r.FolderContextMenu, r.TagContextMenu].includes(e)
    }
    ,
    function(e) {
        e.NoteToolbar = "noteToolbar",
        e.EditorToolbar = "editorToolbar"
    }(t.ToolbarButtonLocation || (t.ToolbarButtonLocation = {})),
    function(e) {
        e[e.Int = 1] = "Int",
        e[e.String = 2] = "String",
        e[e.Bool = 3] = "Bool",
        e[e.Array = 4] = "Array",
        e[e.Object = 5] = "Object",
        e[e.Button = 6] = "Button"
    }(t.SettingItemType || (t.SettingItemType = {})),
    function(e) {
        e.MarkdownItPlugin = "markdownItPlugin",
        e.CodeMirrorPlugin = "codeMirrorPlugin"
    }(t.ContentScriptType || (t.ContentScriptType = {}))
}
, function(e, t, n) {
    "use strict";
    var r = this && this.__awaiter || function(e, t, n, r) {
        return new (n || (n = Promise))((function(s, i) {
            function o(e) {
                try {
                    c(r.next(e))
                } catch (e) {
                    i(e)
                }
            }
            function a(e) {
                try {
                    c(r.throw(e))
                } catch (e) {
                    i(e)
                }
            }
            function c(e) {
                var t;
                e.done ? s(e.value) : (t = e.value,
                t instanceof n ? t : new n((function(e) {
                    e(t)
                }
                ))).then(o, a)
            }
            c((r = r.apply(e, t || [])).next())
        }
        ))
    }
    ;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.Panel = void 0;
    const s = n(2);
    t.Panel = class {
        constructor(e) {
            this._settings = e
        }
        get sets() {
            return this._settings
        }
        register() {
            return r(this, void 0, void 0, (function*() {
                this._panel = yield s.default.views.panels.create("yaml.fm.panel"),
                yield s.default.views.panels.addScript(this._panel, "./assets/fontawesome/css/all.min.css"),
                yield s.default.views.panels.addScript(this._panel, "./webview.css"),
                yield s.default.views.panels.addScript(this._panel, "./webview.js"),
                yield s.default.views.panels.onMessage(this._panel, e=>r(this, void 0, void 0, (function*() {}
                ))),
                yield s.default.views.panels.setHtml(this._panel, `\n      <div id="container" style="background:${this.sets.background};font-family:'${this.sets.fontFamily}',sans-serif;font-size:${this.sets.fontSize};">\n        <div id="fm-container">\n          <p style="padding-left:8px;">Loading panel...</p>\n        </div>\n      </div>\n    `)
            }
            ))
        }
        updateWebview(e) {
            return r(this, void 0, void 0, (function*() {
                yield s.default.workspace.selectedNote();
                yield s.default.views.panels.setHtml(this._panel, `\n      <div id="container" style="background:${this.sets.background};font-family:'${this.sets.fontFamily}',sans-serif;font-size:${this.sets.fontSize};">\n        <div id="fm-title" style="height:${this._settings.lineHeight}px;">\n          <span class="fas fa-info-circle" style="color:${this.sets.foreground};"></span>\n          <span class="title" style="color:${this.sets.foreground};">YAML FRONT MATTER</span>\n        </div>\n        <div id="fm-container">\n          <table>\n            <thead>\n              <tr>\n                <th>Key</th>\n                <th>Value(s)</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr>\n                <td>KeyA</td>\n                <td>X</td>\n              </tr>\n              <tr>\n                <td>ListKey</td>\n                <td>\n                  <ul>\n                    <li>list item 1</li>\n                    <li>list item 2</li>\n                    <li>list item 3</li>\n                  </ul>\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    `)
            }
            ))
        }
        toggleVisibility() {
            return r(this, void 0, void 0, (function*() {
                const e = yield s.default.views.panels.visible(this._panel);
                yield s.default.views.panels.show(this._panel, !e)
            }
            ))
        }
    }
}
, function(e, t, n) {
    e.exports = n(10).YAML
}
, function(e, t, n) {
    "use strict";
    var r = n(11)
      , s = n(12)
      , i = n(3)
      , o = n(0)
      , a = n(4);
    n(1);
    class c extends s.Document {
        constructor(e) {
            super(Object.assign({}, s.defaultOptions, e))
        }
    }
    function l(e, t) {
        const n = r.parse(e)
          , s = new c(t).parse(n[0]);
        if (n.length > 1) {
            const e = "Source contains multiple documents; please use YAML.parseAllDocuments()";
            s.errors.unshift(new o.YAMLSemanticError(n[1],e))
        }
        return s
    }
    const u = {
        createNode: function(e, t=!0, n) {
            void 0 === n && "string" == typeof t && (n = t,
            t = !0);
            const r = Object.assign({}, s.Document.defaults[s.defaultOptions.version], s.defaultOptions);
            return new i.Schema(r).createNode(e, t, n)
        },
        defaultOptions: s.defaultOptions,
        Document: c,
        parse: function(e, t) {
            const n = l(e, t);
            if (n.warnings.forEach(e=>a.warn(e)),
            n.errors.length > 0)
                throw n.errors[0];
            return n.toJSON()
        },
        parseAllDocuments: function(e, t) {
            const n = [];
            let s;
            for (const i of r.parse(e)) {
                const e = new c(t);
                e.parse(i, s),
                n.push(e),
                s = e
            }
            return n
        },
        parseCST: r.parse,
        parseDocument: l,
        scalarOptions: s.scalarOptions,
        stringify: function(e, t) {
            const n = new c(t);
            return n.contents = e,
            String(n)
        }
    };
    t.YAML = u
}
, function(e, t, n) {
    "use strict";
    var r = n(0);
    class s extends r.Node {
        constructor() {
            super(r.Type.BLANK_LINE)
        }
        get includesTrailingLines() {
            return !0
        }
        parse(e, t) {
            return this.context = e,
            this.range = new r.Range(t,t + 1),
            t + 1
        }
    }
    class i extends r.Node {
        constructor(e, t) {
            super(e, t),
            this.node = null
        }
        get includesTrailingLines() {
            return !!this.node && this.node.includesTrailingLines
        }
        parse(e, t) {
            this.context = e;
            const {parseNode: n, src: i} = e;
            let {atLineStart: o, lineStart: a} = e;
            o || this.type !== r.Type.SEQ_ITEM || (this.error = new r.YAMLSemanticError(this,"Sequence items must not have preceding content on the same line"));
            const c = o ? t - a : e.indent;
            let l = r.Node.endOfWhiteSpace(i, t + 1)
              , u = i[l];
            const f = "#" === u
              , h = [];
            let d = null;
            for (; "\n" === u || "#" === u; ) {
                if ("#" === u) {
                    const e = r.Node.endOfLine(i, l + 1);
                    h.push(new r.Range(l,e)),
                    l = e
                } else {
                    o = !0,
                    a = l + 1;
                    "\n" === i[r.Node.endOfWhiteSpace(i, a)] && 0 === h.length && (d = new s,
                    a = d.parse({
                        src: i
                    }, a)),
                    l = r.Node.endOfIndent(i, a)
                }
                u = i[l]
            }
            if (r.Node.nextNodeIsIndented(u, l - (a + c), this.type !== r.Type.SEQ_ITEM) ? this.node = n({
                atLineStart: o,
                inCollection: !1,
                indent: c,
                lineStart: a,
                parent: this
            }, l) : u && a > t + 1 && (l = a - 1),
            this.node) {
                if (d) {
                    const t = e.parent.items || e.parent.contents;
                    t && t.push(d)
                }
                h.length && Array.prototype.push.apply(this.props, h),
                l = this.node.range.end
            } else if (f) {
                const e = h[0];
                this.props.push(e),
                l = e.end
            } else
                l = r.Node.endOfLine(i, t + 1);
            const p = this.node ? this.node.valueRange.end : l;
            return this.valueRange = new r.Range(t,p),
            l
        }
        setOrigRanges(e, t) {
            return t = super.setOrigRanges(e, t),
            this.node ? this.node.setOrigRanges(e, t) : t
        }
        toString() {
            const {context: {src: e}, node: t, range: n, value: s} = this;
            if (null != s)
                return s;
            const i = t ? e.slice(n.start, t.range.start) + String(t) : e.slice(n.start, n.end);
            return r.Node.addStringTerminator(e, n.end, i)
        }
    }
    class o extends r.Node {
        constructor() {
            super(r.Type.COMMENT)
        }
        parse(e, t) {
            this.context = e;
            const n = this.parseComment(t);
            return this.range = new r.Range(t,n),
            n
        }
    }
    function a(e) {
        let t = e;
        for (; t instanceof i; )
            t = t.node;
        if (!(t instanceof c))
            return null;
        const n = t.items.length;
        let s = -1;
        for (let e = n - 1; e >= 0; --e) {
            const n = t.items[e];
            if (n.type === r.Type.COMMENT) {
                const {indent: t, lineStart: r} = n.context;
                if (t > 0 && n.range.start >= r + t)
                    break;
                s = e
            } else {
                if (n.type !== r.Type.BLANK_LINE)
                    break;
                s = e
            }
        }
        if (-1 === s)
            return null;
        const o = t.items.splice(s, n - s)
          , a = o[0].range.start;
        for (; t.range.end = a,
        t.valueRange && t.valueRange.end > a && (t.valueRange.end = a),
        t !== e; )
            t = t.context.parent;
        return o
    }
    class c extends r.Node {
        static nextContentHasIndent(e, t, n) {
            const s = r.Node.endOfLine(e, t) + 1
              , i = e[t = r.Node.endOfWhiteSpace(e, s)];
            return !!i && (t >= s + n || ("#" === i || "\n" === i) && c.nextContentHasIndent(e, t, n))
        }
        constructor(e) {
            super(e.type === r.Type.SEQ_ITEM ? r.Type.SEQ : r.Type.MAP);
            for (let t = e.props.length - 1; t >= 0; --t)
                if (e.props[t].start < e.context.lineStart) {
                    this.props = e.props.slice(0, t + 1),
                    e.props = e.props.slice(t + 1);
                    const n = e.props[0] || e.valueRange;
                    e.range.start = n.start;
                    break
                }
            this.items = [e];
            const t = a(e);
            t && Array.prototype.push.apply(this.items, t)
        }
        get includesTrailingLines() {
            return this.items.length > 0
        }
        parse(e, t) {
            this.context = e;
            const {parseNode: n, src: i} = e;
            let l = r.Node.startOfLine(i, t);
            const u = this.items[0];
            u.context.parent = this,
            this.valueRange = r.Range.copy(u.valueRange);
            const f = u.range.start - u.context.lineStart;
            let h = t;
            h = r.Node.normalizeOffset(i, h);
            let d = i[h]
              , p = r.Node.endOfWhiteSpace(i, l) === h
              , g = !1;
            for (; d; ) {
                for (; "\n" === d || "#" === d; ) {
                    if (p && "\n" === d && !g) {
                        const e = new s;
                        if (h = e.parse({
                            src: i
                        }, h),
                        this.valueRange.end = h,
                        h >= i.length) {
                            d = null;
                            break
                        }
                        this.items.push(e),
                        h -= 1
                    } else if ("#" === d) {
                        if (h < l + f && !c.nextContentHasIndent(i, h, f))
                            return h;
                        const e = new o;
                        if (h = e.parse({
                            indent: f,
                            lineStart: l,
                            src: i
                        }, h),
                        this.items.push(e),
                        this.valueRange.end = h,
                        h >= i.length) {
                            d = null;
                            break
                        }
                    }
                    if (l = h + 1,
                    h = r.Node.endOfIndent(i, l),
                    r.Node.atBlank(i, h)) {
                        const e = r.Node.endOfWhiteSpace(i, h)
                          , t = i[e];
                        t && "\n" !== t && "#" !== t || (h = e)
                    }
                    d = i[h],
                    p = !0
                }
                if (!d)
                    break;
                if (h !== l + f && (p || ":" !== d)) {
                    if (h < l + f) {
                        l > t && (h = l);
                        break
                    }
                    if (!this.error) {
                        const e = "All collection items must start at the same column";
                        this.error = new r.YAMLSyntaxError(this,e)
                    }
                }
                if (u.type === r.Type.SEQ_ITEM) {
                    if ("-" !== d) {
                        l > t && (h = l);
                        break
                    }
                } else if ("-" === d && !this.error) {
                    const e = i[h + 1];
                    if (!e || "\n" === e || "\t" === e || " " === e) {
                        const e = "A collection cannot be both a mapping and a sequence";
                        this.error = new r.YAMLSyntaxError(this,e)
                    }
                }
                const e = n({
                    atLineStart: p,
                    inCollection: !0,
                    indent: f,
                    lineStart: l,
                    parent: this
                }, h);
                if (!e)
                    return h;
                if (this.items.push(e),
                this.valueRange.end = e.valueRange.end,
                h = r.Node.normalizeOffset(i, e.range.end),
                d = i[h],
                p = !1,
                g = e.includesTrailingLines,
                d) {
                    let e = h - 1
                      , t = i[e];
                    for (; " " === t || "\t" === t; )
                        t = i[--e];
                    "\n" === t && (l = e + 1,
                    p = !0)
                }
                const m = a(e);
                m && Array.prototype.push.apply(this.items, m)
            }
            return h
        }
        setOrigRanges(e, t) {
            return t = super.setOrigRanges(e, t),
            this.items.forEach(n=>{
                t = n.setOrigRanges(e, t)
            }
            ),
            t
        }
        toString() {
            const {context: {src: e}, items: t, range: n, value: s} = this;
            if (null != s)
                return s;
            let i = e.slice(n.start, t[0].range.start) + String(t[0]);
            for (let e = 1; e < t.length; ++e) {
                const n = t[e]
                  , {atLineStart: r, indent: s} = n.context;
                if (r)
                    for (let e = 0; e < s; ++e)
                        i += " ";
                i += String(n)
            }
            return r.Node.addStringTerminator(e, n.end, i)
        }
    }
    class l extends r.Node {
        constructor() {
            super(r.Type.DIRECTIVE),
            this.name = null
        }
        get parameters() {
            const e = this.rawValue;
            return e ? e.trim().split(/[ \t]+/) : []
        }
        parseName(e) {
            const {src: t} = this.context;
            let n = e
              , r = t[n];
            for (; r && "\n" !== r && "\t" !== r && " " !== r; )
                r = t[n += 1];
            return this.name = t.slice(e, n),
            n
        }
        parseParameters(e) {
            const {src: t} = this.context;
            let n = e
              , s = t[n];
            for (; s && "\n" !== s && "#" !== s; )
                s = t[n += 1];
            return this.valueRange = new r.Range(e,n),
            n
        }
        parse(e, t) {
            this.context = e;
            let n = this.parseName(t + 1);
            return n = this.parseParameters(n),
            n = this.parseComment(n),
            this.range = new r.Range(t,n),
            n
        }
    }
    class u extends r.Node {
        static startCommentOrEndBlankLine(e, t) {
            const n = r.Node.endOfWhiteSpace(e, t)
              , s = e[n];
            return "#" === s || "\n" === s ? n : t
        }
        constructor() {
            super(r.Type.DOCUMENT),
            this.directives = null,
            this.contents = null,
            this.directivesEndMarker = null,
            this.documentEndMarker = null
        }
        parseDirectives(e) {
            const {src: t} = this.context;
            this.directives = [];
            let n = !0
              , i = !1
              , a = e;
            for (; !r.Node.atDocumentBoundary(t, a, r.Char.DIRECTIVES_END); )
                switch (a = u.startCommentOrEndBlankLine(t, a),
                t[a]) {
                case "\n":
                    if (n) {
                        const e = new s;
                        a = e.parse({
                            src: t
                        }, a),
                        a < t.length && this.directives.push(e)
                    } else
                        a += 1,
                        n = !0;
                    break;
                case "#":
                    {
                        const e = new o;
                        a = e.parse({
                            src: t
                        }, a),
                        this.directives.push(e),
                        n = !1
                    }
                    break;
                case "%":
                    {
                        const e = new l;
                        a = e.parse({
                            parent: this,
                            src: t
                        }, a),
                        this.directives.push(e),
                        i = !0,
                        n = !1
                    }
                    break;
                default:
                    return i ? this.error = new r.YAMLSemanticError(this,"Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives,
                    this.directives = []),
                    a
                }
            return t[a] ? (this.directivesEndMarker = new r.Range(a,a + 3),
            a + 3) : (i ? this.error = new r.YAMLSemanticError(this,"Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives,
            this.directives = []),
            a)
        }
        parseContents(e) {
            const {parseNode: t, src: n} = this.context;
            this.contents || (this.contents = []);
            let i = e;
            for (; "-" === n[i - 1]; )
                i -= 1;
            let c = r.Node.endOfWhiteSpace(n, e)
              , l = i === e;
            for (this.valueRange = new r.Range(c); !r.Node.atDocumentBoundary(n, c, r.Char.DOCUMENT_END); ) {
                switch (n[c]) {
                case "\n":
                    if (l) {
                        const e = new s;
                        c = e.parse({
                            src: n
                        }, c),
                        c < n.length && this.contents.push(e)
                    } else
                        c += 1,
                        l = !0;
                    i = c;
                    break;
                case "#":
                    {
                        const e = new o;
                        c = e.parse({
                            src: n
                        }, c),
                        this.contents.push(e),
                        l = !1
                    }
                    break;
                default:
                    {
                        const e = r.Node.endOfIndent(n, c)
                          , s = t({
                            atLineStart: l,
                            indent: -1,
                            inFlow: !1,
                            inCollection: !1,
                            lineStart: i,
                            parent: this
                        }, e);
                        if (!s)
                            return this.valueRange.end = e;
                        this.contents.push(s),
                        c = s.range.end,
                        l = !1;
                        const o = a(s);
                        o && Array.prototype.push.apply(this.contents, o)
                    }
                }
                c = u.startCommentOrEndBlankLine(n, c)
            }
            if (this.valueRange.end = c,
            n[c] && (this.documentEndMarker = new r.Range(c,c + 3),
            c += 3,
            n[c])) {
                if (c = r.Node.endOfWhiteSpace(n, c),
                "#" === n[c]) {
                    const e = new o;
                    c = e.parse({
                        src: n
                    }, c),
                    this.contents.push(e)
                }
                switch (n[c]) {
                case "\n":
                    c += 1;
                    break;
                case void 0:
                    break;
                default:
                    this.error = new r.YAMLSyntaxError(this,"Document end marker line cannot have a non-comment suffix")
                }
            }
            return c
        }
        parse(e, t) {
            e.root = this,
            this.context = e;
            const {src: n} = e;
            let r = 65279 === n.charCodeAt(t) ? t + 1 : t;
            return r = this.parseDirectives(r),
            r = this.parseContents(r),
            r
        }
        setOrigRanges(e, t) {
            return t = super.setOrigRanges(e, t),
            this.directives.forEach(n=>{
                t = n.setOrigRanges(e, t)
            }
            ),
            this.directivesEndMarker && (t = this.directivesEndMarker.setOrigRange(e, t)),
            this.contents.forEach(n=>{
                t = n.setOrigRanges(e, t)
            }
            ),
            this.documentEndMarker && (t = this.documentEndMarker.setOrigRange(e, t)),
            t
        }
        toString() {
            const {contents: e, directives: t, value: n} = this;
            if (null != n)
                return n;
            let s = t.join("");
            return e.length > 0 && ((t.length > 0 || e[0].type === r.Type.COMMENT) && (s += "---\n"),
            s += e.join("")),
            "\n" !== s[s.length - 1] && (s += "\n"),
            s
        }
    }
    class f extends r.Node {
        parse(e, t) {
            this.context = e;
            const {src: n} = e;
            let s = r.Node.endOfIdentifier(n, t + 1);
            return this.valueRange = new r.Range(t + 1,s),
            s = r.Node.endOfWhiteSpace(n, s),
            s = this.parseComment(s),
            s
        }
    }
    const h = "CLIP"
      , d = "KEEP"
      , p = "STRIP";
    class g extends r.Node {
        constructor(e, t) {
            super(e, t),
            this.blockIndent = null,
            this.chomping = h,
            this.header = null
        }
        get includesTrailingLines() {
            return this.chomping === d
        }
        get strValue() {
            if (!this.valueRange || !this.context)
                return null;
            let {start: e, end: t} = this.valueRange;
            const {indent: n, src: s} = this.context;
            if (this.valueRange.isEmpty())
                return "";
            let i = null
              , o = s[t - 1];
            for (; "\n" === o || "\t" === o || " " === o; ) {
                if (t -= 1,
                t <= e) {
                    if (this.chomping === d)
                        break;
                    return ""
                }
                "\n" === o && (i = t),
                o = s[t - 1]
            }
            let a = t + 1;
            i && (this.chomping === d ? (a = i,
            t = this.valueRange.end) : t = i);
            const c = n + this.blockIndent
              , l = this.type === r.Type.BLOCK_FOLDED;
            let u = !0
              , f = ""
              , h = ""
              , g = !1;
            for (let n = e; n < t; ++n) {
                for (let e = 0; e < c && " " === s[n]; ++e)
                    n += 1;
                const e = s[n];
                if ("\n" === e)
                    "\n" === h ? f += "\n" : h = "\n";
                else {
                    const i = r.Node.endOfLine(s, n)
                      , o = s.slice(n, i);
                    n = i,
                    l && (" " === e || "\t" === e) && n < a ? (" " === h ? h = "\n" : g || u || "\n" !== h || (h = "\n\n"),
                    f += h + o,
                    h = i < t && s[i] || "",
                    g = !0) : (f += h + o,
                    h = l && n < a ? " " : "\n",
                    g = !1),
                    u && "" !== o && (u = !1)
                }
            }
            return this.chomping === p ? f : f + "\n"
        }
        parseBlockHeader(e) {
            const {src: t} = this.context;
            let n = e + 1
              , s = "";
            for (; ; ) {
                const i = t[n];
                switch (i) {
                case "-":
                    this.chomping = p;
                    break;
                case "+":
                    this.chomping = d;
                    break;
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    s += i;
                    break;
                default:
                    return this.blockIndent = Number(s) || null,
                    this.header = new r.Range(e,n),
                    n
                }
                n += 1
            }
        }
        parseBlockValue(e) {
            const {indent: t, src: n} = this.context
              , s = !!this.blockIndent;
            let i = e
              , o = e
              , a = 1;
            for (let e = n[i]; "\n" === e && (i += 1,
            !r.Node.atDocumentBoundary(n, i)); e = n[i]) {
                const e = r.Node.endOfBlockIndent(n, t, i);
                if (null === e)
                    break;
                const c = n[e]
                  , l = e - (i + t);
                if (this.blockIndent) {
                    if (c && "\n" !== c && l < this.blockIndent) {
                        if ("#" === n[e])
                            break;
                        if (!this.error) {
                            const e = "Block scalars must not be less indented than their " + (s ? "explicit indentation indicator" : "first line");
                            this.error = new r.YAMLSemanticError(this,e)
                        }
                    }
                } else if ("\n" !== n[e]) {
                    if (l < a) {
                        const e = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                        this.error = new r.YAMLSemanticError(this,e)
                    }
                    this.blockIndent = l
                } else
                    l > a && (a = l);
                i = "\n" === n[e] ? e : o = r.Node.endOfLine(n, e)
            }
            return this.chomping !== d && (i = n[o] ? o + 1 : o),
            this.valueRange = new r.Range(e + 1,i),
            i
        }
        parse(e, t) {
            this.context = e;
            const {src: n} = e;
            let s = this.parseBlockHeader(t);
            return s = r.Node.endOfWhiteSpace(n, s),
            s = this.parseComment(s),
            s = this.parseBlockValue(s),
            s
        }
        setOrigRanges(e, t) {
            return t = super.setOrigRanges(e, t),
            this.header ? this.header.setOrigRange(e, t) : t
        }
    }
    class m extends r.Node {
        constructor(e, t) {
            super(e, t),
            this.items = null
        }
        prevNodeIsJsonLike(e=this.items.length) {
            const t = this.items[e - 1];
            return !!t && (t.jsonLike || t.type === r.Type.COMMENT && this.prevNodeIsJsonLike(e - 1))
        }
        parse(e, t) {
            this.context = e;
            const {parseNode: n, src: i} = e;
            let {indent: a, lineStart: c} = e
              , l = i[t];
            this.items = [{
                char: l,
                offset: t
            }];
            let u = r.Node.endOfWhiteSpace(i, t + 1);
            for (l = i[u]; l && "]" !== l && "}" !== l; ) {
                switch (l) {
                case "\n":
                    c = u + 1;
                    if ("\n" === i[r.Node.endOfWhiteSpace(i, c)]) {
                        const e = new s;
                        c = e.parse({
                            src: i
                        }, c),
                        this.items.push(e)
                    }
                    if (u = r.Node.endOfIndent(i, c),
                    u <= c + a && (l = i[u],
                    u < c + a || "]" !== l && "}" !== l)) {
                        const e = "Insufficient indentation in flow collection";
                        this.error = new r.YAMLSemanticError(this,e)
                    }
                    break;
                case ",":
                    this.items.push({
                        char: l,
                        offset: u
                    }),
                    u += 1;
                    break;
                case "#":
                    {
                        const e = new o;
                        u = e.parse({
                            src: i
                        }, u),
                        this.items.push(e)
                    }
                    break;
                case "?":
                case ":":
                    {
                        const e = i[u + 1];
                        if ("\n" === e || "\t" === e || " " === e || "," === e || ":" === l && this.prevNodeIsJsonLike()) {
                            this.items.push({
                                char: l,
                                offset: u
                            }),
                            u += 1;
                            break
                        }
                    }
                default:
                    {
                        const e = n({
                            atLineStart: !1,
                            inCollection: !1,
                            inFlow: !0,
                            indent: -1,
                            lineStart: c,
                            parent: this
                        }, u);
                        if (!e)
                            return this.valueRange = new r.Range(t,u),
                            u;
                        this.items.push(e),
                        u = r.Node.normalizeOffset(i, e.range.end)
                    }
                }
                u = r.Node.endOfWhiteSpace(i, u),
                l = i[u]
            }
            return this.valueRange = new r.Range(t,u + 1),
            l && (this.items.push({
                char: l,
                offset: u
            }),
            u = r.Node.endOfWhiteSpace(i, u + 1),
            u = this.parseComment(u)),
            u
        }
        setOrigRanges(e, t) {
            return t = super.setOrigRanges(e, t),
            this.items.forEach(n=>{
                if (n instanceof r.Node)
                    t = n.setOrigRanges(e, t);
                else if (0 === e.length)
                    n.origOffset = n.offset;
                else {
                    let r = t;
                    for (; r < e.length && !(e[r] > n.offset); )
                        ++r;
                    n.origOffset = n.offset + r,
                    t = r
                }
            }
            ),
            t
        }
        toString() {
            const {context: {src: e}, items: t, range: n, value: s} = this;
            if (null != s)
                return s;
            const i = t.filter(e=>e instanceof r.Node);
            let o = ""
              , a = n.start;
            return i.forEach(t=>{
                const n = e.slice(a, t.range.start);
                a = t.range.end,
                o += n + String(t),
                "\n" === o[o.length - 1] && "\n" !== e[a - 1] && "\n" === e[a] && (a += 1)
            }
            ),
            o += e.slice(a, n.end),
            r.Node.addStringTerminator(e, n.end, o)
        }
    }
    class y extends r.Node {
        static endOfQuote(e, t) {
            let n = e[t];
            for (; n && '"' !== n; )
                n = e[t += "\\" === n ? 2 : 1];
            return t + 1
        }
        get strValue() {
            if (!this.valueRange || !this.context)
                return null;
            const e = []
              , {start: t, end: n} = this.valueRange
              , {indent: s, src: i} = this.context;
            '"' !== i[n - 1] && e.push(new r.YAMLSyntaxError(this,'Missing closing "quote'));
            let o = "";
            for (let a = t + 1; a < n - 1; ++a) {
                const t = i[a];
                if ("\n" === t) {
                    r.Node.atDocumentBoundary(i, a + 1) && e.push(new r.YAMLSemanticError(this,"Document boundary indicators are not allowed within string values"));
                    const {fold: t, offset: n, error: c} = r.Node.foldNewline(i, a, s);
                    o += t,
                    a = n,
                    c && e.push(new r.YAMLSemanticError(this,"Multi-line double-quoted string needs to be sufficiently indented"))
                } else if ("\\" === t)
                    switch (a += 1,
                    i[a]) {
                    case "0":
                        o += "\0";
                        break;
                    case "a":
                        o += "";
                        break;
                    case "b":
                        o += "\b";
                        break;
                    case "e":
                        o += "";
                        break;
                    case "f":
                        o += "\f";
                        break;
                    case "n":
                        o += "\n";
                        break;
                    case "r":
                        o += "\r";
                        break;
                    case "t":
                        o += "\t";
                        break;
                    case "v":
                        o += "\v";
                        break;
                    case "N":
                        o += "";
                        break;
                    case "_":
                        o += " ";
                        break;
                    case "L":
                        o += "\u2028";
                        break;
                    case "P":
                        o += "\u2029";
                        break;
                    case " ":
                        o += " ";
                        break;
                    case '"':
                        o += '"';
                        break;
                    case "/":
                        o += "/";
                        break;
                    case "\\":
                        o += "\\";
                        break;
                    case "\t":
                        o += "\t";
                        break;
                    case "x":
                        o += this.parseCharCode(a + 1, 2, e),
                        a += 2;
                        break;
                    case "u":
                        o += this.parseCharCode(a + 1, 4, e),
                        a += 4;
                        break;
                    case "U":
                        o += this.parseCharCode(a + 1, 8, e),
                        a += 8;
                        break;
                    case "\n":
                        for (; " " === i[a + 1] || "\t" === i[a + 1]; )
                            a += 1;
                        break;
                    default:
                        e.push(new r.YAMLSyntaxError(this,"Invalid escape sequence " + i.substr(a - 1, 2))),
                        o += "\\" + i[a]
                    }
                else if (" " === t || "\t" === t) {
                    const e = a;
                    let n = i[a + 1];
                    for (; " " === n || "\t" === n; )
                        a += 1,
                        n = i[a + 1];
                    "\n" !== n && (o += a > e ? i.slice(e, a + 1) : t)
                } else
                    o += t
            }
            return e.length > 0 ? {
                errors: e,
                str: o
            } : o
        }
        parseCharCode(e, t, n) {
            const {src: s} = this.context
              , i = s.substr(e, t)
              , o = i.length === t && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
            return isNaN(o) ? (n.push(new r.YAMLSyntaxError(this,"Invalid escape sequence " + s.substr(e - 2, t + 2))),
            s.substr(e - 2, t + 2)) : String.fromCodePoint(o)
        }
        parse(e, t) {
            this.context = e;
            const {src: n} = e;
            let s = y.endOfQuote(n, t + 1);
            return this.valueRange = new r.Range(t,s),
            s = r.Node.endOfWhiteSpace(n, s),
            s = this.parseComment(s),
            s
        }
    }
    class v extends r.Node {
        static endOfQuote(e, t) {
            let n = e[t];
            for (; n; )
                if ("'" === n) {
                    if ("'" !== e[t + 1])
                        break;
                    n = e[t += 2]
                } else
                    n = e[t += 1];
            return t + 1
        }
        get strValue() {
            if (!this.valueRange || !this.context)
                return null;
            const e = []
              , {start: t, end: n} = this.valueRange
              , {indent: s, src: i} = this.context;
            "'" !== i[n - 1] && e.push(new r.YAMLSyntaxError(this,"Missing closing 'quote"));
            let o = "";
            for (let a = t + 1; a < n - 1; ++a) {
                const t = i[a];
                if ("\n" === t) {
                    r.Node.atDocumentBoundary(i, a + 1) && e.push(new r.YAMLSemanticError(this,"Document boundary indicators are not allowed within string values"));
                    const {fold: t, offset: n, error: c} = r.Node.foldNewline(i, a, s);
                    o += t,
                    a = n,
                    c && e.push(new r.YAMLSemanticError(this,"Multi-line single-quoted string needs to be sufficiently indented"))
                } else if ("'" === t)
                    o += t,
                    a += 1,
                    "'" !== i[a] && e.push(new r.YAMLSyntaxError(this,"Unescaped single quote? This should not happen."));
                else if (" " === t || "\t" === t) {
                    const e = a;
                    let n = i[a + 1];
                    for (; " " === n || "\t" === n; )
                        a += 1,
                        n = i[a + 1];
                    "\n" !== n && (o += a > e ? i.slice(e, a + 1) : t)
                } else
                    o += t
            }
            return e.length > 0 ? {
                errors: e,
                str: o
            } : o
        }
        parse(e, t) {
            this.context = e;
            const {src: n} = e;
            let s = v.endOfQuote(n, t + 1);
            return this.valueRange = new r.Range(t,s),
            s = r.Node.endOfWhiteSpace(n, s),
            s = this.parseComment(s),
            s
        }
    }
    class S {
        static parseType(e, t, n) {
            switch (e[t]) {
            case "*":
                return r.Type.ALIAS;
            case ">":
                return r.Type.BLOCK_FOLDED;
            case "|":
                return r.Type.BLOCK_LITERAL;
            case "{":
                return r.Type.FLOW_MAP;
            case "[":
                return r.Type.FLOW_SEQ;
            case "?":
                return !n && r.Node.atBlank(e, t + 1, !0) ? r.Type.MAP_KEY : r.Type.PLAIN;
            case ":":
                return !n && r.Node.atBlank(e, t + 1, !0) ? r.Type.MAP_VALUE : r.Type.PLAIN;
            case "-":
                return !n && r.Node.atBlank(e, t + 1, !0) ? r.Type.SEQ_ITEM : r.Type.PLAIN;
            case '"':
                return r.Type.QUOTE_DOUBLE;
            case "'":
                return r.Type.QUOTE_SINGLE;
            default:
                return r.Type.PLAIN
            }
        }
        constructor(e={}, {atLineStart: t, inCollection: n, inFlow: s, indent: o, lineStart: a, parent: l}={}) {
            r._defineProperty(this, "parseNode", (e,t)=>{
                if (r.Node.atDocumentBoundary(this.src, t))
                    return null;
                const n = new S(this,e)
                  , {props: s, type: o, valueStart: a} = n.parseProps(t)
                  , l = function(e, t) {
                    switch (e) {
                    case r.Type.ALIAS:
                        return new f(e,t);
                    case r.Type.BLOCK_FOLDED:
                    case r.Type.BLOCK_LITERAL:
                        return new g(e,t);
                    case r.Type.FLOW_MAP:
                    case r.Type.FLOW_SEQ:
                        return new m(e,t);
                    case r.Type.MAP_KEY:
                    case r.Type.MAP_VALUE:
                    case r.Type.SEQ_ITEM:
                        return new i(e,t);
                    case r.Type.COMMENT:
                    case r.Type.PLAIN:
                        return new r.PlainValue(e,t);
                    case r.Type.QUOTE_DOUBLE:
                        return new y(e,t);
                    case r.Type.QUOTE_SINGLE:
                        return new v(e,t);
                    default:
                        return null
                    }
                }(o, s);
                let u = l.parse(n, a);
                if (l.range = new r.Range(t,u),
                u <= t && (l.error = new Error("Node#parse consumed no characters"),
                l.error.parseEnd = u,
                l.error.source = l,
                l.range.end = t + 1),
                n.nodeStartsCollection(l)) {
                    l.error || n.atLineStart || n.parent.type !== r.Type.DOCUMENT || (l.error = new r.YAMLSyntaxError(l,"Block collection must not have preceding content here (e.g. directives-end indicator)"));
                    const e = new c(l);
                    return u = e.parse(new S(n), u),
                    e.range = new r.Range(t,u),
                    e
                }
                return l
            }
            ),
            this.atLineStart = null != t ? t : e.atLineStart || !1,
            this.inCollection = null != n ? n : e.inCollection || !1,
            this.inFlow = null != s ? s : e.inFlow || !1,
            this.indent = null != o ? o : e.indent,
            this.lineStart = null != a ? a : e.lineStart,
            this.parent = null != l ? l : e.parent || {},
            this.root = e.root,
            this.src = e.src
        }
        nodeStartsCollection(e) {
            const {inCollection: t, inFlow: n, src: s} = this;
            if (t || n)
                return !1;
            if (e instanceof i)
                return !0;
            let o = e.range.end;
            return "\n" !== s[o] && "\n" !== s[o - 1] && (o = r.Node.endOfWhiteSpace(s, o),
            ":" === s[o])
        }
        parseProps(e) {
            const {inFlow: t, parent: n, src: s} = this
              , i = [];
            let o = !1
              , a = s[e = this.atLineStart ? r.Node.endOfIndent(s, e) : r.Node.endOfWhiteSpace(s, e)];
            for (; a === r.Char.ANCHOR || a === r.Char.COMMENT || a === r.Char.TAG || "\n" === a; ) {
                if ("\n" === a) {
                    let t, i = e;
                    do {
                        t = i + 1,
                        i = r.Node.endOfIndent(s, t)
                    } while ("\n" === s[i]);const a = i - (t + this.indent)
                      , c = n.type === r.Type.SEQ_ITEM && n.context.atLineStart;
                    if ("#" !== s[i] && !r.Node.nextNodeIsIndented(s[i], a, !c))
                        break;
                    this.atLineStart = !0,
                    this.lineStart = t,
                    o = !1,
                    e = i
                } else if (a === r.Char.COMMENT) {
                    const t = r.Node.endOfLine(s, e + 1);
                    i.push(new r.Range(e,t)),
                    e = t
                } else {
                    let t = r.Node.endOfIdentifier(s, e + 1);
                    a === r.Char.TAG && "," === s[t] && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(s.slice(e + 1, t + 13)) && (t = r.Node.endOfIdentifier(s, t + 5)),
                    i.push(new r.Range(e,t)),
                    o = !0,
                    e = r.Node.endOfWhiteSpace(s, t)
                }
                a = s[e]
            }
            o && ":" === a && r.Node.atBlank(s, e + 1, !0) && (e -= 1);
            return {
                props: i,
                type: S.parseType(s, e, t),
                valueStart: e
            }
        }
    }
    t.parse = function(e) {
        const t = [];
        -1 !== e.indexOf("\r") && (e = e.replace(/\r\n?/g, (e,n)=>(e.length > 1 && t.push(n),
        "\n")));
        const n = [];
        let r = 0;
        do {
            const t = new u
              , s = new S({
                src: e
            });
            r = t.parse(s, r),
            n.push(t)
        } while (r < e.length);return n.setOrigRanges = ()=>{
            if (0 === t.length)
                return !1;
            for (let e = 1; e < t.length; ++e)
                t[e] -= e;
            let e = 0;
            for (let r = 0; r < n.length; ++r)
                e = n[r].setOrigRanges(t, e);
            return t.splice(0, t.length),
            !0
        }
        ,
        n.toString = ()=>n.join("...\n"),
        n
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(0)
      , s = n(1)
      , i = n(3);
    const o = {
        get binary() {
            return s.binaryOptions
        },
        set binary(e) {
            Object.assign(s.binaryOptions, e)
        },
        get bool() {
            return s.boolOptions
        },
        set bool(e) {
            Object.assign(s.boolOptions, e)
        },
        get int() {
            return s.intOptions
        },
        set int(e) {
            Object.assign(s.intOptions, e)
        },
        get null() {
            return s.nullOptions
        },
        set null(e) {
            Object.assign(s.nullOptions, e)
        },
        get str() {
            return s.strOptions
        },
        set str(e) {
            Object.assign(s.strOptions, e)
        }
    }
      , a = {
        "1.0": {
            schema: "yaml-1.1",
            merge: !0,
            tagPrefixes: [{
                handle: "!",
                prefix: r.defaultTagPrefix
            }, {
                handle: "!!",
                prefix: "tag:private.yaml.org,2002:"
            }]
        },
        1.1: {
            schema: "yaml-1.1",
            merge: !0,
            tagPrefixes: [{
                handle: "!",
                prefix: "!"
            }, {
                handle: "!!",
                prefix: r.defaultTagPrefix
            }]
        },
        1.2: {
            schema: "core",
            merge: !1,
            tagPrefixes: [{
                handle: "!",
                prefix: "!"
            }, {
                handle: "!!",
                prefix: r.defaultTagPrefix
            }]
        }
    };
    function c(e, t) {
        if ("1.0" === (e.version || e.options.version)) {
            const e = t.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
            if (e)
                return "!" + e[1];
            const n = t.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
            return n ? `!${n[1]}/${n[2]}` : "!" + t.replace(/^tag:/, "")
        }
        let n = e.tagPrefixes.find(e=>0 === t.indexOf(e.prefix));
        if (!n) {
            const r = e.getDefaults().tagPrefixes;
            n = r && r.find(e=>0 === t.indexOf(e.prefix))
        }
        if (!n)
            return "!" === t[0] ? t : `!<${t}>`;
        const r = t.substr(n.prefix.length).replace(/[!,[\]{}]/g, e=>({
            "!": "%21",
            ",": "%2C",
            "[": "%5B",
            "]": "%5D",
            "{": "%7B",
            "}": "%7D"
        }[e]));
        return n.handle + r
    }
    function l(e, t, n, r) {
        const {anchors: i, schema: o} = t.doc;
        let a;
        if (!(e instanceof s.Node)) {
            const t = {
                aliasNodes: [],
                onTagObj: e=>a = e,
                prevObjects: new Map
            };
            e = o.createNode(e, !0, null, t);
            for (const e of t.aliasNodes) {
                e.source = e.source.node;
                let t = i.getName(e.source);
                t || (t = i.newName(),
                i.map[t] = e.source)
            }
        }
        if (e instanceof s.Pair)
            return e.toString(t, n, r);
        a || (a = function(e, t) {
            if (t instanceof s.Alias)
                return s.Alias;
            if (t.tag) {
                const n = e.filter(e=>e.tag === t.tag);
                if (n.length > 0)
                    return n.find(e=>e.format === t.format) || n[0]
            }
            let n, r;
            if (t instanceof s.Scalar) {
                r = t.value;
                const s = e.filter(e=>e.identify && e.identify(r) || e.class && r instanceof e.class);
                n = s.find(e=>e.format === t.format) || s.find(e=>!e.format)
            } else
                r = t,
                n = e.find(e=>e.nodeClass && r instanceof e.nodeClass);
            if (!n) {
                const e = r && r.constructor ? r.constructor.name : typeof r;
                throw new Error(`Tag not resolved for ${e} value`)
            }
            return n
        }(o.tags, e));
        const l = function(e, t, {anchors: n, doc: r}) {
            const s = []
              , i = r.anchors.getName(e);
            return i && (n[i] = e,
            s.push("&" + i)),
            e.tag ? s.push(c(r, e.tag)) : t.default || s.push(c(r, t.tag)),
            s.join(" ")
        }(e, a, t);
        l.length > 0 && (t.indentAtStart = (t.indentAtStart || 0) + l.length + 1);
        const u = "function" == typeof a.stringify ? a.stringify(e, t, n, r) : e instanceof s.Scalar ? s.stringifyString(e, t, n, r) : e.toString(t, n, r);
        return l ? e instanceof s.Scalar || "{" === u[0] || "[" === u[0] ? `${l} ${u}` : `${l}\n${t.indent}${u}` : u
    }
    class u {
        static validAnchorNode(e) {
            return e instanceof s.Scalar || e instanceof s.YAMLSeq || e instanceof s.YAMLMap
        }
        constructor(e) {
            r._defineProperty(this, "map", Object.create(null)),
            this.prefix = e
        }
        createAlias(e, t) {
            return this.setAnchor(e, t),
            new s.Alias(e)
        }
        createMergePair(...e) {
            const t = new s.Merge;
            return t.value.items = e.map(e=>{
                if (e instanceof s.Alias) {
                    if (e.source instanceof s.YAMLMap)
                        return e
                } else if (e instanceof s.YAMLMap)
                    return this.createAlias(e);
                throw new Error("Merge sources must be Map nodes or their Aliases")
            }
            ),
            t
        }
        getName(e) {
            const {map: t} = this;
            return Object.keys(t).find(n=>t[n] === e)
        }
        getNames() {
            return Object.keys(this.map)
        }
        getNode(e) {
            return this.map[e]
        }
        newName(e) {
            e || (e = this.prefix);
            const t = Object.keys(this.map);
            for (let n = 1; ; ++n) {
                const r = `${e}${n}`;
                if (!t.includes(r))
                    return r
            }
        }
        resolveNodes() {
            const {map: e, _cstAliases: t} = this;
            Object.keys(e).forEach(t=>{
                e[t] = e[t].resolved
            }
            ),
            t.forEach(e=>{
                e.source = e.source.resolved
            }
            ),
            delete this._cstAliases
        }
        setAnchor(e, t) {
            if (null != e && !u.validAnchorNode(e))
                throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
            if (t && /[\x00-\x19\s,[\]{}]/.test(t))
                throw new Error("Anchor names must not contain whitespace or control characters");
            const {map: n} = this
              , r = e && Object.keys(n).find(t=>n[t] === e);
            if (r) {
                if (!t)
                    return r;
                r !== t && (delete n[r],
                n[t] = e)
            } else {
                if (!t) {
                    if (!e)
                        return null;
                    t = this.newName()
                }
                n[t] = e
            }
            return t
        }
    }
    const f = (e,t)=>{
        if (e && "object" == typeof e) {
            const {tag: n} = e;
            e instanceof s.Collection ? (n && (t[n] = !0),
            e.items.forEach(e=>f(e, t))) : e instanceof s.Pair ? (f(e.key, t),
            f(e.value, t)) : e instanceof s.Scalar && n && (t[n] = !0)
        }
        return t
    }
    ;
    function h({tagPrefixes: e}, t) {
        const [n,s] = t.parameters;
        if (!n || !s) {
            const e = "Insufficient parameters given for %TAG directive";
            throw new r.YAMLSemanticError(t,e)
        }
        if (e.some(e=>e.handle === n)) {
            const e = "The %TAG directive must only be given at most once per handle in the same document.";
            throw new r.YAMLSemanticError(t,e)
        }
        return {
            handle: n,
            prefix: s
        }
    }
    function d(e, t) {
        let[n] = t.parameters;
        if ("YAML:1.0" === t.name && (n = "1.0"),
        !n) {
            const e = "Insufficient parameters given for %YAML directive";
            throw new r.YAMLSemanticError(t,e)
        }
        if (!a[n]) {
            const s = `Document will be parsed as YAML ${e.version || e.options.version} rather than YAML ${n}`;
            e.warnings.push(new r.YAMLWarning(t,s))
        }
        return n
    }
    function p(e) {
        if (e instanceof s.Collection)
            return !0;
        throw new Error("Expected a YAML collection as document contents")
    }
    class g {
        constructor(e) {
            this.anchors = new u(e.anchorPrefix),
            this.commentBefore = null,
            this.comment = null,
            this.contents = null,
            this.directivesEndMarker = null,
            this.errors = [],
            this.options = e,
            this.schema = null,
            this.tagPrefixes = [],
            this.version = null,
            this.warnings = []
        }
        add(e) {
            return p(this.contents),
            this.contents.add(e)
        }
        addIn(e, t) {
            p(this.contents),
            this.contents.addIn(e, t)
        }
        delete(e) {
            return p(this.contents),
            this.contents.delete(e)
        }
        deleteIn(e) {
            return s.isEmptyPath(e) ? null != this.contents && (this.contents = null,
            !0) : (p(this.contents),
            this.contents.deleteIn(e))
        }
        getDefaults() {
            return g.defaults[this.version] || g.defaults[this.options.version] || {}
        }
        get(e, t) {
            return this.contents instanceof s.Collection ? this.contents.get(e, t) : void 0
        }
        getIn(e, t) {
            return s.isEmptyPath(e) ? !t && this.contents instanceof s.Scalar ? this.contents.value : this.contents : this.contents instanceof s.Collection ? this.contents.getIn(e, t) : void 0
        }
        has(e) {
            return this.contents instanceof s.Collection && this.contents.has(e)
        }
        hasIn(e) {
            return s.isEmptyPath(e) ? void 0 !== this.contents : this.contents instanceof s.Collection && this.contents.hasIn(e)
        }
        set(e, t) {
            p(this.contents),
            this.contents.set(e, t)
        }
        setIn(e, t) {
            s.isEmptyPath(e) ? this.contents = t : (p(this.contents),
            this.contents.setIn(e, t))
        }
        setSchema(e, t) {
            if (!e && !t && this.schema)
                return;
            "number" == typeof e && (e = e.toFixed(1)),
            "1.0" === e || "1.1" === e || "1.2" === e ? (this.version ? this.version = e : this.options.version = e,
            delete this.options.schema) : e && "string" == typeof e && (this.options.schema = e),
            Array.isArray(t) && (this.options.customTags = t);
            const n = Object.assign({}, this.getDefaults(), this.options);
            this.schema = new i.Schema(n)
        }
        parse(e, t) {
            this.options.keepCstNodes && (this.cstNode = e),
            this.options.keepNodeTypes && (this.type = "DOCUMENT");
            const {directives: n=[], contents: i=[], directivesEndMarker: o, error: a, valueRange: c} = e;
            if (a && (a.source || (a.source = this),
            this.errors.push(a)),
            function(e, t, n) {
                const s = [];
                let i = !1;
                for (const n of t) {
                    const {comment: t, name: o} = n;
                    switch (o) {
                    case "TAG":
                        try {
                            e.tagPrefixes.push(h(e, n))
                        } catch (t) {
                            e.errors.push(t)
                        }
                        i = !0;
                        break;
                    case "YAML":
                    case "YAML:1.0":
                        if (e.version) {
                            const t = "The %YAML directive must only be given at most once per document.";
                            e.errors.push(new r.YAMLSemanticError(n,t))
                        }
                        try {
                            e.version = d(e, n)
                        } catch (t) {
                            e.errors.push(t)
                        }
                        i = !0;
                        break;
                    default:
                        if (o) {
                            const t = "YAML only supports %TAG and %YAML directives, and not %" + o;
                            e.warnings.push(new r.YAMLWarning(n,t))
                        }
                    }
                    t && s.push(t)
                }
                if (n && !i && "1.1" === (e.version || n.version || e.options.version)) {
                    const t = ({handle: e, prefix: t})=>({
                        handle: e,
                        prefix: t
                    });
                    e.tagPrefixes = n.tagPrefixes.map(t),
                    e.version = n.version
                }
                e.commentBefore = s.join("\n") || null
            }(this, n, t),
            o && (this.directivesEndMarker = !0),
            this.range = c ? [c.start, c.end] : null,
            this.setSchema(),
            this.anchors._cstAliases = [],
            function(e, t) {
                const n = {
                    before: [],
                    after: []
                };
                let i = void 0
                  , o = !1;
                for (const a of t)
                    if (a.valueRange) {
                        if (void 0 !== i) {
                            const t = "Document contains trailing content not separated by a ... or --- line";
                            e.errors.push(new r.YAMLSyntaxError(a,t));
                            break
                        }
                        const t = s.resolveNode(e, a);
                        o && (t.spaceBefore = !0,
                        o = !1),
                        i = t
                    } else if (null !== a.comment) {
                        (void 0 === i ? n.before : n.after).push(a.comment)
                    } else
                        a.type === r.Type.BLANK_LINE && (o = !0,
                        void 0 === i && n.before.length > 0 && !e.commentBefore && (e.commentBefore = n.before.join("\n"),
                        n.before = []));
                if (e.contents = i || null,
                i) {
                    const t = n.before.join("\n");
                    if (t) {
                        const e = i instanceof s.Collection && i.items[0] ? i.items[0] : i;
                        e.commentBefore = e.commentBefore ? `${t}\n${e.commentBefore}` : t
                    }
                    e.comment = n.after.join("\n") || null
                } else
                    e.comment = n.before.concat(n.after).join("\n") || null
            }(this, i),
            this.anchors.resolveNodes(),
            this.options.prettyErrors) {
                for (const e of this.errors)
                    e instanceof r.YAMLError && e.makePretty();
                for (const e of this.warnings)
                    e instanceof r.YAMLError && e.makePretty()
            }
            return this
        }
        listNonDefaultTags() {
            return (e = this.contents,
            Object.keys(f(e, {}))).filter(e=>0 !== e.indexOf(i.Schema.defaultPrefix));
            var e
        }
        setTagPrefix(e, t) {
            if ("!" !== e[0] || "!" !== e[e.length - 1])
                throw new Error("Handle must start and end with !");
            if (t) {
                const n = this.tagPrefixes.find(t=>t.handle === e);
                n ? n.prefix = t : this.tagPrefixes.push({
                    handle: e,
                    prefix: t
                })
            } else
                this.tagPrefixes = this.tagPrefixes.filter(t=>t.handle !== e)
        }
        toJSON(e, t) {
            const {keepBlobsInJSON: n, mapAsMap: r, maxAliasCount: i} = this.options
              , o = n && ("string" != typeof e || !(this.contents instanceof s.Scalar))
              , a = {
                doc: this,
                indentStep: "  ",
                keep: o,
                mapAsMap: o && !!r,
                maxAliasCount: i,
                stringify: l
            }
              , c = Object.keys(this.anchors.map);
            c.length > 0 && (a.anchors = new Map(c.map(e=>[this.anchors.map[e], {
                alias: [],
                aliasCount: 0,
                count: 1
            }])));
            const u = s.toJSON(this.contents, e, a);
            if ("function" == typeof t && a.anchors)
                for (const {count: e, res: n} of a.anchors.values())
                    t(n, e);
            return u
        }
        toString() {
            if (this.errors.length > 0)
                throw new Error("Document with errors cannot be stringified");
            const e = this.options.indent;
            if (!Number.isInteger(e) || e <= 0) {
                const t = JSON.stringify(e);
                throw new Error('"indent" option must be a positive integer, not ' + t)
            }
            this.setSchema();
            const t = [];
            let n = !1;
            if (this.version) {
                let e = "%YAML 1.2";
                "yaml-1.1" === this.schema.name && ("1.0" === this.version ? e = "%YAML:1.0" : "1.1" === this.version && (e = "%YAML 1.1")),
                t.push(e),
                n = !0
            }
            const r = this.listNonDefaultTags();
            this.tagPrefixes.forEach(({handle: e, prefix: s})=>{
                r.some(e=>0 === e.indexOf(s)) && (t.push(`%TAG ${e} ${s}`),
                n = !0)
            }
            ),
            (n || this.directivesEndMarker) && t.push("---"),
            this.commentBefore && (!n && this.directivesEndMarker || t.unshift(""),
            t.unshift(this.commentBefore.replace(/^/gm, "#")));
            const i = {
                anchors: Object.create(null),
                doc: this,
                indent: "",
                indentStep: " ".repeat(e),
                stringify: l
            };
            let o = !1
              , a = null;
            if (this.contents) {
                this.contents instanceof s.Node && (this.contents.spaceBefore && (n || this.directivesEndMarker) && t.push(""),
                this.contents.commentBefore && t.push(this.contents.commentBefore.replace(/^/gm, "#")),
                i.forceBlockIndent = !!this.comment,
                a = this.contents.comment);
                const e = a ? null : ()=>o = !0
                  , r = l(this.contents, i, ()=>a = null, e);
                t.push(s.addComment(r, "", a))
            } else
                void 0 !== this.contents && t.push(l(this.contents, i));
            return this.comment && (o && !a || "" === t[t.length - 1] || t.push(""),
            t.push(this.comment.replace(/^/gm, "#"))),
            t.join("\n") + "\n"
        }
    }
    r._defineProperty(g, "defaults", a),
    t.Document = g,
    t.defaultOptions = {
        anchorPrefix: "a",
        customTags: null,
        indent: 2,
        indentSeq: !0,
        keepCstNodes: !1,
        keepNodeTypes: !0,
        keepBlobsInJSON: !0,
        mapAsMap: !1,
        maxAliasCount: 100,
        prettyErrors: !1,
        simpleKeys: !1,
        version: "1.2"
    },
    t.scalarOptions = o
}
]);
